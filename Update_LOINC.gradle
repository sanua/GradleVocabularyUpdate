/*
****************************
* LOINC Vocabulary update  *
* Version 0.0.6            *
****************************
*/

group 'com.sci.vocabulary'
version '1.0-SNAPSHOT'

apply plugin: 'java'

apply plugin: 'groovy'

sourceCompatibility = 1.8

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'org.apache.poi:poi:3.9'
        classpath 'org.apache.poi:poi-ooxml:3.9'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.5.2'
        classpath 'com.squareup.okhttp3:okhttp:3.5.0'

        classpath 'commons-io:commons-io:2.5'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.apache.httpcomponents:httpcore:4.4.6'
        classpath 'commons-httpclient:commons-httpclient:3.1'
        classpath 'commons-io:commons-io:2.5'

        classpath 'org.apache.commons:commons-lang3:3.5'
        classpath 'com.google.guava:guava:21.0'

        classpath group: 'commons-io', name: 'commons-io', version: '2.5'
    }
}
/*
repositories {
    mavenLocal()
    mavenCentral()
}
dependencies {
    classpath 'org.apache.poi:poi:3.9'
    classpath 'org.apache.poi:poi-ooxml:3.9'
}

*/

import groovy.io.FileType
import org.apache.poi.ss.usermodel.Cell
import org.apache.poi.ss.usermodel.Row
import org.apache.poi.ss.usermodel.Workbook
import org.apache.poi.ss.usermodel.WorkbookFactory
import org.apache.poi.ss.usermodel.Sheet

/*
task compileOne(type: JavaCompile) {
    source = sourceSets.main.java.srcDir
    include 'inc.odysseus.utils/StringBuilderWrapper.java'
    classpath = sourceSets.main.output.classesDir
    destinationDir = sourceSets.main.output.classesDir
}
compileOne.options.compilerArgs = ["-sourcepath", "${projectDir}/src/main/java"]

*/
/**
 * JAVA-CODE SECTION.
 * 
 * Temporary java code are located here. If future it's need to move it toi separate java-module.
 */

import com.google.common.base.Joiner;
import com.google.common.io.Files;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.FileUtils
import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.NameValuePair;
import org.apache.http.Header;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.cookie.Cookie;
import org.apache.http.entity.BufferedHttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.cookie.BasicClientCookie;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.HttpContext;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.http.Consts;
import org.apache.http.util.EntityUtils;

import java.io.*;
import java.net.URISyntaxException
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import java.util.*
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.io.FileUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.ss.usermodel.*;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import java.util.stream.Collectors;

/**
 * Created by Sanders on 5/23/2017.
 */

public class DownloadResourceHelper {
    /**
     * Names of using cookies.
     *
     * COOKIE_JSESSIONID - session identifier on UMLS login service;
     * COOKIE_CASTGC - client authentication cookie for UMLS login service;
     * COOKIE_MOD_AUTH_CAS - client ticket-authentication cookie for UMLS download service.
     */
    public static final String COOKIE_JSESSIONID = "JSESSIONID";
    public static final String COOKIE_CASTGC = "CASTGC";
    public static final String COOKIE_MOD_AUTH_CAS = "MOD_AUTH_CAS";
    public static final int NUMBER_OF_ATTEMPTS = 3;

    private CloseableHttpClient httpClient;
    private File downloadPath;
    /**
     * Presumably "Login Ticket" parameter.
     * Used on user form during authentication, generated by UMLS login service when new session is created.
     */
    private String ltParam;

    /**
     * Class-level cookie store
     */
    private List<Cookie> localCookieStore;

    /**
     * Apache CookieStore for all cookies.
     * Isn't used because of using class-level cookie store.
     */
//    private CookieStore cookieStore;

    /**
     * Instance of Download Helper.
     */
    private static DownloadResourceHelper singleIntance;

    /**
     * Contructor
     */
        private DownloadResourceHelper() {
            this(null);
        }

        private DownloadResourceHelper(File downloadPath) {
            if (downloadPath == null || !downloadPath.exists()) {
                // Prepare temporary storage for content
                this.downloadPath = Files.createTempDir();
                this.tempDir.deleteOnExit();
            } else
                this.downloadPath = downloadPath;

            this.localCookieStore = new ArrayList<Cookie>();

            // Create HttpClient
            this.httpClient = HttpClients.custom()
                    .disableCookieManagement()
                    .disableRedirectHandling()
                    .addInterceptorLast(new HttpRequestInterceptor() {
                public void process(HttpRequest httpRequest, HttpContext httpContext) throws HttpException, IOException {
                    /**
                     * Add common request headers
                     */
                    httpRequest.addHeader("Connection", "keep-alive");
                    httpRequest.addHeader("Upgrade-Insecure-Requests", "1");
                    httpRequest.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
                    httpRequest.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
                    httpRequest.addHeader("Accept-Encoding", "gzip, deflate, sdch, br");
                    httpRequest.addHeader("Accept-Language", "en-US,en;q=0.8,ru;q=0.6,uk;q=0.4");
                    httpRequest.addHeader("Cache-Control", "no-cache");
                    httpRequest.addHeader("Pragma", "no-cache");
                }
            }).addInterceptorLast(new HttpResponseInterceptor() {
                public void process(HttpResponse httpResponse, HttpContext httpContext) throws HttpException, IOException {
                    /**
                     * Adding of cookie from response to class-level local storage.
                     */
                    saveClientCookie(httpResponse);
                }
            }).build();
    }

    /**
     * Extract header value from response
     *
     * @param response
     * @param name
     * @return
     */
    private String getResponseHeaderValue(HttpResponse response, String name) {
        Header header = response.getLastHeader(name);
        if (header == null) {
            return "";
        } else {
            return header.getValue();
        }
    }

    /**
     * Convert array to List
     *
     * @param objects
     * @return
     */
    private <T> List<T> getListFromArray(T[] objects) {
        List<T> result = new ArrayList<T>();
        for (T c: objects) {
            if (c != null) {
                result.add(c);
            }
        }
        return result;
    }

    /**
     * Return all saved client's cookies.
     *
     * @return
     */
    private List<Cookie> getAllStoredCookies() {
        List<Cookie> ckList = new ArrayList<Cookie>();
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            ckList.add(it.next());
        }
        return ckList;
    }

    /**
     * Get client cookie from local storage.
     *
     * @param name
     * @return
     */
    private Cookie getClientCookie(String name) {
        Cookie cookie = null;
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(name)) {
                cookie = c;
                break;
            }
        }
        return cookie;
    }

    /**
     * Class-level Cookie Storage.
     *
     * @param request
     */
    private void saveClientCookie(HttpResponse request) {
        Header cookieHeader = request.getLastHeader("Set-Cookie");
        if (cookieHeader == null)
            return;
        String nameValue = cookieHeader.getValue().substring(0, cookieHeader.getValue().indexOf(";"));
        Cookie newCookie = new BasicClientCookie(nameValue.split("=")[0], nameValue.split("=")[1]);

        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(newCookie.getName()))
                return;
        }
        this.localCookieStore.add(newCookie);
    }

    /**
     * Add multiple cookies to response.
     *
     * @param request
     * @param cookies
     * @return
     */
    private HttpRequest setRequestCookies(HttpRequest request, List<Cookie> cookies) {
        if (cookies == null || cookies.isEmpty())
            return request;

        StringBuilder sb = new StringBuilder();
        for (Cookie c: cookies) {
            if (sb.toString().length() != 0)
                sb.append(";");
            sb.append(String.format("%s=%s", c.getName(), c.getValue()));
        }
        request.addHeader("Cookie", sb.toString());
        return request;
    }

    /**
     * Convert parameter's map to name-value format, for convenient usage for Apache's classes.
     *
     * @param params
     * @return
     */
    private List<NameValuePair> toMapNameValuePairs(Map<String, String> params) {
        List<NameValuePair> nvpList = new ArrayList<NameValuePair>();
        Iterator<Map.Entry<String, String>> it = params.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> entry = it.next();
            String name = entry.getKey();
            String value = entry.getValue();
            if (StringUtils.isNotBlank(name) && StringUtils.isNoneBlank(value))
                nvpList.add(new BasicNameValuePair(name, value));
        }
        return nvpList;
    }

    /**
     * Prepare GET request.
     *
     * @param url
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url) throws IOException, URISyntaxException {
        return prepareGet(url, null, null);
    }

    /**
     * Prepare GET request with adding multiple cookies.
     *
     * @param url
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, List<Cookie> cookies) throws IOException, URISyntaxException {
        return prepareGet(url, null, cookies);
    }

    /**
     * Prepare parametrised GET request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        if (params != null && !params.isEmpty()) {
            URIBuilder uriBuilder = new URIBuilder(url);
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            uriBuilder.addParameters(pairList);
            url = uriBuilder.toString();
        }
        HttpGet request = new HttpGet(url);
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Prepare parametrised POST request
     *
     * @param url
     * @param params
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params) throws IOException, URISyntaxException {
        return preparePost(url, params, null);
    }

    /**
     * Prepare parametrised POST request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        HttpPost request = new HttpPost(url);
        if (params != null && !params.isEmpty()) {
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            request.setEntity(new UrlEncodedFormEntity(pairList));
        }
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Get instance
     *
     * @return
     */
    public static DownloadResourceHelper getDownloadResourceHelper(File downloadPath) {
        if (singleIntance == null) {
            singleIntance = new DownloadResourceHelper(downloadPath);
        }
        return singleIntance;
    }

    public String repeatableDownloadResourceUmls(String loginUrl, String userName, String password, String fileUrl, String fileName) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadResourceUmls(loginUrl, userName, password, fileUrl, fileName, true, NUMBER_OF_ATTEMPTS);
    }

    public String downloadResourceUmls(String loginUrl, String userName, String password, String fileUrl, String fileName) throws IOException {
        return downloadResourceUmls(loginUrl, userName, password, fileUrl, fileName, false, 0);
    }

    // Just download UMLS routine
    private String downloadUmls(String fileUrl, String fileName, boolean isTryRedownload, int numberOfTries) {
        CloseableHttpResponse response = null;
        OutputStream outputStream = null;
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_MOD_AUTH_CAS));
            HttpGet request = prepareGet(fileUrl, cookies);
            response = httpClient.execute(request);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries > 0) {
                    try {
                        if (response != null) {
                            response.close();
                        }
                    } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadUmls(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, Consts.UTF_8);

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(new StringBuilderWrapper(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength)));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copy(bufEntity.getContent(), outputStream);
            outputStream.flush();

            return fileName;
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }

            if (outputStream != null) {
                outputStream.close();
            }
        }
    }

    // Login and download resource
    public String downloadResourceUmls(String loginUrl, String userName, String password, String fileUrl, String fileName, boolean isTryRedownload, int numberOfTries) throws IOException {
        CloseableHttpResponse response = null;
        // REQUEST 1
        // Just to get first JSESSION cookie
        try {
            HttpGet request = prepareGet(loginUrl);
            response = httpClient.execute(request);

            // Remember dynamically generated presumably "Login Ticket" form parameter
            String responseBody = EntityUtils.toString(response.getEntity()).trim();
            Pattern ltPattern = Pattern.compile("name=\"lt\" value=\"(\\w+)\"");
            Matcher m = ltPattern.matcher(responseBody);
            while (m.find()) {
                this.ltParam = m.group(1);
            }
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }
        }

        // REQUEST 2
        // Login
        System.out.println "${new StringBuilderWrapper("Login UMLS service...")}"
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            HttpPost request = preparePost(loginUrl, params, cookies);
            request.addHeader("Content-Type", "application/x-www-form-urlencoded");
            response = httpClient.execute(request);

        } catch (Exception e) {
            System.out.println("Exception occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 3
        // Get ticket for requested resource
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            cookies.add(getClientCookie(COOKIE_CASTGC));
            HttpGet request = prepareGet(fileUrl, cookies);
            response = httpClient.execute(request);

            /**
             * Get URL for further processing
             */
            fileUrl = getResponseHeaderValue(response, "Location");
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 4
        // Authorize on download service
        try {
            HttpGet request = prepareGet(fileUrl);
            response = httpClient.execute(request);

            /**
             * Get URL for further processing
             */
            fileUrl = getResponseHeaderValue(response,"Location");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 5
        // Download resource
        return downloadUmls(fileUrl, fileName, isTryRedownload, numberOfTries);
    }

    public boolean loginLoinc(String loginUrl, String userName, String password) throws IOException {
        CloseableHttpResponse response = null;
        // Login LOINC services
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("log", userName);
            params.put("pwd", password);
            params.put("wp-submit", "Log In");
            HttpPost request = preparePost(loginUrl, params);
            response = httpClient.execute(request);

            return true;
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
            return false;
        } finally {
            if (response != null) {
                response.close();
            }
        }
    }

    public String downloadResourceLoinc(String fileUrl, String fileName, String packageDescription) throws IOException {
        return downloadResourceLoinc(fileUrl, fileName, packageDescription, false, 0);
    }

    public String repeatableDownloadResourceLoinc(String fileUrl, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadResourceLoinc(fileUrl, fileName, packageDescription, true, NUMBER_OF_ATTEMPTS);
    }

    public String downloadResourceLoinc(String fileUrl, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) throws IOException {
        OutputStream outputStream = null;
        CloseableHttpResponse response = null;
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("tc_accepted", "1");
            params.put("tc_submit", "Download");
            List<Cookie> cookies = getAllStoredCookies();
            HttpPost request = preparePost(fileUrl, params, cookies);
            response = httpClient.execute(request);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries > 0) {
                    try {
                        if (response != null) {
                            response.close();
                        }
                    } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadResourceLoinc(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, Consts.UTF_8);
            String responseBody = writer.toString().trim();

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0) {
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            }
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(new StringBuilderWrapper(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength)));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copy(bufEntity.getContent(), outputStream);
            outputStream.flush();
            
            return fileName;
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}

/**
 * Created by Sanders on 5/26/2017.
 */
public class Xls2CsvHelper {
    
    private File convertPath;
    private static Xls2CsvHelper singleInstance;

    private Xls2CsvHelper() {
        this(null);
    }

    private Xls2CsvHelper(File convertPath) {
        if (convertPath == null || !convertPath.exists()) {
            this.convertPath = Files.createTempDir()
        } else
            this.convertPath = convertPath;
    }

    public static Xls2CsvHelper getXls2CsvHelper(File convertPath) {
        if (singleInstance == null) {
            singleInstance = new Xls2CsvHelper(convertPath);
        }
        return singleInstance;
    }

    private String convertSheetByName(Workbook workbook) {
        return convertSheetByName(workbook, null, null);
    }

    private String convertSheetByName(Workbook workbook, String name, String skipColumnsAfterName) {
        /**
         * Get Sheet by name of first sheet is name is not specified.
         */
        Sheet sheet = null;
        if (StringUtils.isNotBlank(name)) {
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                sheet = workbook.getSheetAt(i);
                if (sheet.getSheetName().equalsIgnoreCase(name)) {
                    break;
                }
            }
            if (sheet == null)
                throw new IllegalArgumentException(String.format("No Excel Sheet found for name: %s", name));
        } else
            sheet = workbook.getSheetAt(0);
        /**
         * Read data from cells
         */
        int skipColumnNumber = Integer.MAX_VALUE;
        StringBuffer data = new StringBuffer();
        for (int i = 0; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            boolean isCheckColumnsSkip = (i ==0 && StringUtils.isNotBlank(skipColumnsAfterName));
            if (row != null) {
                cell_loop:
                for (int j = 0; j < row.getLastCellNum(); j++) {
                    Cell cell = row.getCell(j);
                    if (cell == null) {
                        data.append(";");
                    } else {
                        cell.setCellType(Cell.CELL_TYPE_STRING);
                        String cellText = cell.toString().trim();
                        if (isCheckColumnsSkip  && cellText.equalsIgnoreCase(skipColumnsAfterName)) {
                            skipColumnNumber = j;
                        }
                        if (j <= skipColumnNumber) {
                            data.append("\"" + cellText.replaceAll("\"", "'").replaceAll("[\\n\\r]", " ") + "\"");
                            if (j < skipColumnNumber && (j < sheet.getLastRowNum())) {
                                data.append(";");
                            }
                        } else
                            break cell_loop;
                    }
                }
                data.append('\n');
            }
        }
        return data.toString();
    }


    public void convertHcpcs(String inputFile, String outputFile) throws IOException {
        System.out.println("\n\tConversion of HCPCS data started");
        File f = new File(outputFile.substring(0, outputFile.lastIndexOf(File.separator) + 1));
        if (!f.exists()) {
            f.mkdir();
        } else {
            FileUtils.cleanDirectory(f);
        }
        /**
         * For storing data into CSV files
         */
        String data;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(outputFile);
            /**
             * Get the workbook object for XLS file
             */
            Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFile));
            /**
             * Get data from default (first) sheet and save to file
             */
            data = convertSheetByName(workbook);
            fos.write(data.getBytes());
            fos.flush();
            System.out.println("\tConversion of HCPCS data done");
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    }

    public void convertLoinc(String inputFile, String destFolder, Map<String, String> sheetNameFilePathMap, Map<String, String> sheetNameSkiptColumnsAfterNameMap) throws IOException {
        System.out.println(new StringBuilderWrapper("Conversion of LOINC data started"));
        /**
         * Check if input Except file exists
         */
        File inputFileFullPath = new File(this.convertPath, inputFile);
        if (!inputFileFullPath.exists()) {
            throw new IOException(String.format("No input excel file found by name: %s", inputFileFullPath));
        }
        /**
         * Check output folder exists, if not - create it, otherwise - clean it
         */
        File outPath = new File(this.convertPath, destFolder);
        if (!outPath.exists()) {
            outPath.mkdir();
        } else {
            FileUtils.cleanDirectory(outPath);
        }

        String data;
        FileOutputStream fos = null;
        try {
            /**
             * Get the workbook object for XLS file
             */
            Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFileFullPath));

            Iterator<Map.Entry<String, String>> it = sheetNameFilePathMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry<String, String> sheetPathEntry = it.next();
                String sheetName = sheetPathEntry.getKey();
                String fileName = sheetPathEntry.getValue();
                String skipColumnsAfterName = sheetNameSkiptColumnsAfterNameMap.get(sheetName);
                /**
                 * Get data from first sheet "ANSWERS" and save to file
                 */
                data = convertSheetByName(workbook, sheetName, skipColumnsAfterName);
                
                File savedFilePath = new File(outPath, fileName);
                sheetPathEntry.setValue(savedFilePath);
                System.out.println(new StringBuilderWrapper(String.format("Conversion of Sheet '%s' done. Saved to: '%s'.", sheetName, savedFilePath.getPath())));
                fos = new FileOutputStream(savedFilePath);
                fos.write(data.getBytes());
                fos.flush();
            }
            System.out.println(new StringBuilderWrapper("Conversion of LOINC data done"));
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    }

    public static List<File> getFilesByName(File folder, String nameTemplate, boolean strictSearch) {
        return getFilesByName(folder, nameTemplate, null, strictSearch);
    }

    public static List<File> getFilesByName(File folder, String nameTemplate, String excludeExtension, boolean strictSearch) {
        File[] matchedFiles = folder.listFiles(new FilenameFilter() {
            @Override
            boolean accept(File dir, String name) {
                return name.toLowerCase().indexOf(nameTemplate.trim().toLowerCase()) >= 0 &&
                        (StringUtils.isBlank(excludeExtension) || !name.endsWith("." + excludeExtension));
            }
        })
        List<File> foundFiles = Arrays.asList(matchedFiles);

        if (strictSearch) {
            if (foundFiles.empty)
                throw new GradleException("No file found by name: ${nameTemplate}");
            else if (foundFiles.size() > 1)
                throw new GradleException("More than one files found by name: '${nameTemplate}'");
        }
        return foundFiles;
    }

    public static String copy(String from, String to) {
        Path copyFrom = Paths.get(from);
        Path copyTo = Paths.get(to);
        Path targetFile = Files.copy(copyFrom, copyTo, StandardCopyOption.REPLACE_EXISTING);
        return targetFile.normalize().toString();
    }
}
/**
 * Auxiliary classes. TODO: Further should be used java-defined and compiled only
 */
public class StringBuilderWrapper implements java.lang.Appendable {
    private static final String IDENT_CHAR = " " *4
    private StringBuilder wrapped

    public StringBuilderWrapper() {
        wrapped = new StringBuilder()
    }
    public StringBuilderWrapper(String value) {
        this()
        wrapped.append(IDENT_CHAR).append(value)
    }

    public static StringBuilderWrapper getBuilder() {
        return new StringBuilderWrapper()
    }

    public static String readFromFile(File file) {
        if (file == null)
            return ''
        def builder = getBuilder()
        def br = new BufferedReader(new FileReader(file))
        def strLine
        while ((strLine = br.readLine()) != null) {
                builder.append('\n').append(strLine)
        }
        return builder.toString()
    }

    @Override
    Appendable append(CharSequence csq) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq)
        return this
    }
    @Override
    Appendable append(CharSequence csq, int start, int end) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq, start, end)
        return this
    }
    @Override
    Appendable append(char c) throws IOException {
        wrapped.append(IDENT_CHAR).append(c)
        return this
    }
    @Override
    String toString() {
        return wrapped.toString()
    }
}
/**
 * JAVA-CODE SECTION
 */

// Load LOINC properties
Properties props = new Properties()
props.load(new FileInputStream("${project.getBuildFile().toString().replace('.gradle', '.properties')}"))
props.each {prop ->
    project.ext.set(prop.key, prop.value)
}

def tempDir = File.createTempDir()
tempDir.deleteOnExit()

/**
 * Just renew user schema and prepare it for further vocabulary update
 */
task fastRecreateSchema(description: project.properties['fastRecreate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*       '${description}' action started...     *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['fastRecreate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['fastRecreate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will prepare user schema for vocabulary update routine.
 * It will create auxiliary tables - the "ICD10CM_TABLE","LOINC","MAP_TO","SOURCE_ORGANIZATION","LOINC_ANSWERS","LOINC_FORMS","LOINC_CLASS","CPT_MRSMAP","scccRefset_MapCorrOrFull_INT" in our case, for example.
 */
task createSourceTable(dependsOn: fastRecreateSchema, description: project.properties['createSourceTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*   '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['createSourceTable.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['createSourceTable.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task which will download vocabulary update package from source host.
 * There are many URLs (in see the https://github.com/OHDSI/Vocabulary-v5.0/blob/master/LOINC/readme.md for details)
 */
task downloadUpdatePack(dependsOn: createSourceTable, description: project.properties['downloadUpdatePack.description']) << {
    println '\n\n*******************************************************'
    println '*                                                     *'
    println "*    '${description}' action started...     *"
    println '*                                                     *'
    println '*******************************************************'

    /* Downloading file */
    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    DownloadResourceHelper downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(tempDir);

    // Login LOINC service
    println "\n${new StringBuilderWrapper("Login LOINC service...")}"
    String loginUrl = project.properties['downloadUpdatePack.loinc.loginUrl']
    String userName = project.properties['downloadUpdatePack.loinc.username']
    String password = project.properties['downloadUpdatePack.loinc.password']
    downloadHelper.loginLoinc(loginUrl, userName, password)

    /*************************************************
     * Download 'Full Set' package (from LOINC portal)
     * **********************************************/
    String packageDescription = project.properties['downloadUpdatePack.fullSet.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    String fileUrl = project.properties['downloadUpdatePack.fullSet.fileUrl']
    String defaultFileName = project.properties['downloadUpdatePack.fullSet.fileName']
    String downloadedFileName = downloadHelper.repeatableDownloadResourceLoinc(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.fullSet.fileName', downloadedFileName);

    /*************************************************************
     * Download 'Multiaxial Hierarchy' package (from LOINC portal)
     * ***********************************************************/
    packageDescription = project.properties['downloadUpdatePack.multiaxialHierarchy.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.multiaxialHierarchy.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadResourceLoinc(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.multiaxialHierarchy.fileName', downloadedFileName);

    /*********************************************************
     * Download 'Panels and Forms' package (from LOINC portal)
     * *******************************************************/
    packageDescription = project.properties['downloadUpdatePack.panelsForms.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.panelsForms.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.panelsForms.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadResourceLoinc(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.panelsForms.fileName', downloadedFileName);

    /******************************************************************
     * Download 'CT Expression Association' package (from LOINC portal)
     * ****************************************************************/
    packageDescription = project.properties['downloadUpdatePack.expressionAssociation.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.expressionAssociation.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.expressionAssociation.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadResourceLoinc(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.expressionAssociation.fileName', downloadedFileName);

    /****************************************************
     * Download 'CPT Mappings' package (from UMLS portal)
     * **************************************************/
    packageDescription = project.properties['downloadUpdatePack.cptMappings.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    loginUrl = project.properties['downloadUpdatePack.umls.loginUrl']
    userName = project.properties['downloadUpdatePack.umls.username']
    password = project.properties['downloadUpdatePack.umls.password']
    fileUrl = project.properties['downloadUpdatePack.cptMappings.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.cptMappings.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadResourceUmls(loginUrl, userName, password, fileUrl, defaultFileName);
    project.ext.set('downloadUpdatePack.cptMappings.fileName', downloadedFileName);

    println "\n${new StringBuilderWrapper('Download completed.')}"
    println "${new StringBuilderWrapper("Update packages are saved to the: ${tempDir.getPath()}")}"

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

task extractFiles(dependsOn: downloadUpdatePack, description: project.properties['extractFiles.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /* Extracting file */
    def fileList = []
    def dir = tempDir
    dir.eachFile(FileType.FILES) { file ->
        fileList << file
        if (file.getPath().endsWith('zip')) {
            print new StringBuilderWrapper("Extracting ${file} ...")
            ant.unzip(src: file.getPath(), dest: tempDir, overwrite: false)
            println ' done'
        }
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will com.odysseusinc.convert a XLS data file to CSV format.
 */
task convertData(dependsOn: extractFiles, description: project.properties['convertData.description']) << {
    println '\n\n*************************************************'
    println '*                                               *'
    println "*  '${description}' action started...  *"
    println '*                                               *'
    println '*************************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    def timeFinish = timeStart
    Xls2CsvHelper convertHelper = Xls2CsvHelper.getXls2CsvHelper(tempDir);

    try {
        Map<String, String> sheetNameFilePathMap = new HashMap<String, String>();
        sheetNameFilePathMap.put("ANSWERS", project.properties['convertData.panelsForms.answers.destFileName']);
        sheetNameFilePathMap.put("FORMS", project.properties['convertData.panelsForms.forms.destFileName']);

        Map<String, String> sheetNameSkiptColumnsAfterNameMap = new HashMap<String, String>();
        sheetNameSkiptColumnsAfterNameMap.put("ANSWERS", "DisplayText");
        sheetNameSkiptColumnsAfterNameMap.put("FORMS", "Loinc");

        String fileNameTemplate = "panelsandforms"
        List<File> fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true);
        String inputFile = fileList.get(0).getName()
        String importReadyFolder = "ready_for_import";
        convertHelper.convertLoinc(inputFile, importReadyFolder, sheetNameFilePathMap, sheetNameSkiptColumnsAfterNameMap);

        /**
         * Prepare all other files for import
         */
        String answersCsvFile = sheetNameFilePathMap.get("ANSWERS");
        project.ext.set("import.panelsForms.answers.dataFileName", answersCsvFile);

        String formsCsvFile = sheetNameFilePathMap.get("FORMS");
        project.ext.set("import.panelsForms.forms.dataFileName", formsCsvFile);

        String targetPath = new File(tempDir, importReadyFolder).getPath();

        fileNameTemplate = "loinc.csv";
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true);
        String fileToCopy = fileList.get(0).getName();
        println "\n${new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}")}";
        String loincCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.fullSet.loinc.dataFileName", loincCsvFile);

        fileNameTemplate = "map_to.csv";
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true);
        fileToCopy = fileList.get(0).getName();
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}");
        String mapToCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.fullSet.mapTo.dataFileName", mapToCsvFile);

        fileNameTemplate = "source_organization.csv";
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true);
        fileToCopy = fileList.get(0).getName();
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}");
        String sourceOrganizationCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.fullSet.sourceOrganization.dataFileName", sourceOrganizationCsvFile);

        fileToCopy = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName'].replaceAll(".zip", ".csv");
        fileNameTemplate = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName'].toString();
        fileNameTemplate = fileNameTemplate.substring(0, fileNameTemplate.lastIndexOf("."));
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true);
        fileToCopy = fileList.get(0).getName();
        String multiaxialHierarchyCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.multiaxialHierarchy.dataFileName", multiaxialHierarchyCsvFile);

        File filePath = new File(project.properties['downloadUpdatePack.expressionAssociation.fileName'].replaceAll(".zip", "")
                ,"Full/Refset/Content");
        filePath = new File(tempDir, filePath.getPath());

        fileNameTemplate = "xder2_sscccRefset_LOINCExpressionAssociationFull_INT";
        fileList = convertHelper.getFilesByName(filePath, fileNameTemplate, true);
        fileToCopy = fileList.get(0).getName();
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}");
        String expressionAssociationCsvFile = convertHelper.copy(
                new File(filePath, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.expressionAssociation.dataFileName", expressionAssociationCsvFile);

        fileNameTemplate = "MRSMAP";
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, true);
        fileToCopy = fileList.get(0).getName();
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}");
        String cptMappingsCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("import.cptMappings.dataFileName", cptMappingsCsvFile);

        // Finish action checkpoint
        timeFinish = System.currentTimeMillis()
    }
    catch (FileNotFoundException e) {
        e.printStackTrace()
    }
    catch (IOException e) {
        e.printStackTrace()
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task performed import CSV data to database
 */
task importData(dependsOn: convertData, description: project.properties['import.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*         '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /**
     * Filter import-specific parameters
     */
    Map<String, String> importParams = project.properties.findAll {
        it.getKey().startsWith("import.") && it.getKey().toLowerCase().indexOf("description") < 0;
    };
    /**
     * Group import-specific parameters
     */
    Map<String, String> importParamsGrouped = importParams.groupBy {it.getKey().substring(0, it.getKey().lastIndexOf("."))}

    /**
     * Process import
     */
    Iterator<Map.Entry<?, ?>> importIterator = importParamsGrouped.entrySet().iterator();
    while(importIterator.hasNext()) {
        Map.Entry<?, ?> importEntry = importIterator.next();
        String groupNameLabel = importEntry.getKey().replaceAll("\\.", " ").capitalize();
        Map<String, String> groupParams = importEntry.getValue();
        
        String controlFileName = groupParams.find {it.getKey().toLowerCase().indexOf("controlFileName".toLowerCase()) >= 0}.getValue();
        String dataFileName = groupParams.find {it.getKey().toLowerCase().indexOf("dataFileName".toLowerCase()) >= 0}.getValue();
        String logFileName = groupParams.find {it.getKey().toLowerCase().indexOf("logFileName".toLowerCase()) >= 0}.getValue();
        String discardFileName = groupParams.find {it.getKey().toLowerCase().indexOf("discardFileName".toLowerCase()) >= 0}.getValue();
        String badFileName = groupParams.find {it.getKey().toLowerCase().indexOf("badFileName".toLowerCase()) >= 0}.getValue();
        String streamLogFileName = groupParams.find {it.getKey().toLowerCase().indexOf("streamLogFileName".toLowerCase()) >= 0}.getValue();
        String streamErrorFileName = groupParams.find {it.getKey().toLowerCase().indexOf("streamErrorFileName".toLowerCase()) >= 0}.getValue();

        Map.Entry<String, String> providedEntry = groupParams.find {it.getKey().toLowerCase().indexOf("provided".toLowerCase()) >= 0}
        boolean provided = false;
        if (providedEntry != null) {
            provided = Boolean.valueOf(providedEntry.getValue()).booleanValue();
        }
        if (provided) {
            dataFileName = new File(project.properties['basePath'], dataFileName).getPath();
        }

        println "\n${new StringBuilderWrapper("${groupNameLabel}...")}";
        
        def bosOut = new ByteArrayOutputStream(), bosErr = new ByteArrayOutputStream()
        def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
        exec {
            executable "sqlldr"
            args "USERID=${project.properties['db.userName']}/${project.properties['db.password']}@${project.properties['db.tnsName']} " +
                    "CONTROL=${project.properties['basePath']}/${controlFileName} " +
                    "DATA=$dataFileName " +
                    "LOG=${project.properties['logPath']}/${logFileName} " +
                    "DISCARD=${project.properties['logPath']}/${discardFileName} " +
                    "BAD=${project.properties['logPath']}/${badFileName}"
            standardOutput = bosOut
            errorOutput = bosErr
        }
        def bisOut = new ByteArrayInputStream(bosOut.toByteArray())
        bisOut.withReader { out->
            out.eachLine {
                sout.append(it).append('\n')
            }
        }
        def bisErr = new ByteArrayInputStream(bosErr.toByteArray())
        bisErr.withReader { out ->
            out.eachLine {
                serr.append(it).append('\n')
            }
        }

        // Write to console
        /*
         *  When import prefer to write stream log to console (it's shorter)
         * */
        System.out.println(sout.toString())

        // Write to logfile
        File f = new File("${project.properties['logPath']}/${streamLogFileName}")
        f.write(sout.toString())

        // Write to error file
        f = new File("${project.properties['logPath']}/${streamErrorFileName}")
        f.write(serr.toString())
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Load stage' script.
 * Seems it's is specific for each vocabulary.
 */
task loadStage(dependsOn: importData, description: project.properties['loadStage.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['loadStage.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['loadStage.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['loadStage.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['loadStage.streamErrFileName']}"
    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        System.out.println("IO Exception occurs": ioe.getMessage())
        ioe.printStackTrace()
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    } catch (Exception e) {
        System.out.println("Exception occurs": e.getMessage())
        ioe.printStackTrace()
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Genetic update' script.
 * It's common for all updated vocabularies and located in '\Vocabulary-v5.0\working\generic_update.sql' file.
 */
task genericUpdate(dependsOn: loadStage, description: project.properties['genericUpdate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*     '${description}' action started...      *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['genericUpdate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['genericUpdate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run scripts which allows to see the vocabulary update results
 */
task checkUpdateResults(dependsOn: genericUpdate, description: project.properties['checkUpdateResults.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*  '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['checkUpdateResults.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to log file
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Bootstrap action
 *
 * TODO: Needs to find solution to measure whole task chain execution.
 * TODO: This one via doFirst/doLast actions isn't working.
 */
task startUpdate(dependsOn: checkUpdateResults, description: project.properties['startUpdate.description']) {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*      '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema...\n"

    project.ext['logPath'] = "${project.properties['basePath']}/${project.properties['baseLogPath']}"
    def folder = new File(project.properties['logPath'])
    if (!folder.exists()) {
        folder.mkdirs()
        println "Log directory is created: ${folder.getPath()}"
    } else {
        FileUtils.cleanDirectory(folder)
        println "Log directory is cleaned: ${folder.getPath()}"
    }

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    doLast {
        // Finish action checkpoint
        def timeFinish = System.currentTimeMillis()

        // Measure time execution
        def timeElapsed = (timeFinish - timeStart) / 1000
        println "\n\nTotal time elapsed: ${timeElapsed} seconds."
        println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema is completed successfully..."
        println '***********************************************'
        println '*                                             *'
        println "*      '${description}' action is done...       *"
        println '*                                             *'
        println '***********************************************\n'
    }
}