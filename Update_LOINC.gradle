/*
****************************
* LOINC Vocabulary update  *
* Version 0.0.7            *
****************************
*/

group 'com.sci.vocabulary'
version '1.0-SNAPSHOT'

apply plugin: 'java'

apply plugin: 'groovy'

sourceCompatibility = 1.8

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'org.apache.poi:poi:3.9'
        classpath 'org.apache.poi:poi-ooxml:3.9'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.5.2'
        classpath 'com.squareup.okhttp3:okhttp:3.5.0'

        classpath 'commons-io:commons-io:2.5'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.apache.httpcomponents:httpcore:4.4.6'
        classpath 'commons-httpclient:commons-httpclient:3.1'
        classpath 'commons-io:commons-io:2.5'

        classpath 'org.apache.commons:commons-lang3:3.5'
        classpath 'com.google.guava:guava:21.0'

        classpath group: 'commons-io', name: 'commons-io', version: '2.5'
    }
}
/*
repositories {
    mavenLocal()
    mavenCentral()
}
dependencies {
    classpath 'org.apache.poi:poi:3.9'
    classpath 'org.apache.poi:poi-ooxml:3.9'
}

*/

import groovy.io.FileType
import org.apache.poi.ss.usermodel.Cell
import org.apache.poi.ss.usermodel.Row
import org.apache.poi.ss.usermodel.Workbook
import org.apache.poi.ss.usermodel.WorkbookFactory
import org.apache.poi.ss.usermodel.Sheet

/*
task compileOne(type: JavaCompile) {
    source = sourceSets.main.java.srcDir
    include 'inc.odysseus.utils/StringBuilderWrapper.java'
    classpath = sourceSets.main.output.classesDir
    destinationDir = sourceSets.main.output.classesDir
}
compileOne.options.compilerArgs = ["-sourcepath", "${projectDir}/src/main/java"]

*/

/**
 * JAVA-CODE SECTION.
 * 
 * Temporary java code are located here. If future it's need to move it toi separate java-module.
 */

import com.google.common.base.Joiner;
import com.google.common.io.Files;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.FileUtils
import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.NameValuePair;
import org.apache.http.Header;
import org.apache.http.HttpHost;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.cookie.Cookie;
import org.apache.http.entity.BufferedHttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.client.LaxRedirectStrategy;
import org.apache.http.impl.cookie.BasicClientCookie;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.HttpContext;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.http.util.EntityUtils;

import java.io.*;
import java.net.URISyntaxException
import java.nio.charset.StandardCharsets
import java.nio.file.StandardCopyOption
import java.nio.file.StandardOpenOption
import java.util.*
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.poi.ss.usermodel.*;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import java.util.stream.Collectors;

/**
 * Created by Sanders on 5/23/2017.
 */

public class IllegalUpdateStateException extends Exception {
    public IllegalUpdateStateException(String message) {
        super(message);
    }
    public IllegalUpdateStateException(Throwable cause) {
        super(cause);
    }
    public IllegalUpdateStateException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class DownloadResourceHelper {
    /**
     * Names of using cookies.
     *
     * COOKIE_JSESSIONID - session identifier on UMLS login service;
     * COOKIE_CASTGC - client authentication cookie for UMLS login service;
     * COOKIE_MOD_AUTH_CAS - client ticket-authentication cookie for UMLS download service.
     */
    public static final String COOKIE_JSESSIONID = "JSESSIONID";
    public static final String COOKIE_CASTGC = "CASTGC";
    public static final String COOKIE_CASPRIVACY = "CASPRIVACY";
    public static final String COOKIE_MOD_AUTH_CAS = "MOD_AUTH_CAS";
    public static final int NUMBER_OF_ATTEMPTS = 3;

    private CloseableHttpClient httpClient;
    private File downloadPath;
    private Properties resourceProperties;

    /**
     * Presumably "Login Ticket" parameter.
     * Used on user form during authentication, generated by UMLS login service when new session is created.
     */
    private String ltParam;

    /**
     * Class-level cookie store
     */
    private List<Cookie> localCookieStore;

    /**
     * Apache CookieStore for all cookies.
     * Isn't used because of using class-level cookie store.
     */
//    private CookieStore cookieStore;

    /**
     * Instance of Download Helper.
     */
    private static DownloadResourceHelper singleInstance;

    /**
     * Contructor
     */
    private DownloadResourceHelper(File downloadPath, boolean autoRedirects, String propertyFilePath) {
        if (downloadPath == null || !downloadPath.exists()) {
            // Prepare temporary storage for content
            this.downloadPath = Files.createTempDir();
            this.downloadPath.deleteOnExit();
        } else
            this.downloadPath = downloadPath;

        System.out.println(String.format("Used temporary folder: %s", this.downloadPath.getPath()));

        this.localCookieStore = new ArrayList<>();

        // Load resource properties
        this.resourceProperties = loadProps(propertyFilePath);

        // Create HttpClient
        HttpClientBuilder httpClientBuilder = HttpClients.custom()
                //.setProxy(new HttpHost("127.0.0.1", 8888))
                .addInterceptorLast(new HttpRequestInterceptor() {
                    public void process(HttpRequest httpRequest, HttpContext httpContext) throws HttpException, IOException {
                        debugRequestHeaders(httpRequest);
                    }
                })
                .addInterceptorLast(new HttpResponseInterceptor() {
                    public void process(HttpResponse httpResponse, HttpContext httpContext) throws HttpException, IOException {
                        debugResponseHeaders(httpResponse);
                    }
                });

        // Configure HttpClient
        if (autoRedirects) {
            // With automatic redirect processing (further used for UMLS download)
            httpClientBuilder.setRedirectStrategy(new LaxRedirectStrategy()) // adds HTTP REDIRECT support to GET and POST methods
            ;
        } else {
            // With step-by-step redirect processing (firstly used for LOINC download)
            httpClientBuilder
                    .disableCookieManagement()
                    .disableRedirectHandling()
                    .addInterceptorLast(new HttpRequestInterceptor() {
                        public void process(HttpRequest httpRequest, HttpContext httpContext) throws HttpException, IOException {
                            /**
                             * Remove default headers
                             */
                            httpRequest.removeHeaders("Accept");
                            httpRequest.removeHeaders("Accept-Encoding");
                            httpRequest.removeHeaders("Accept-Language");
                            httpRequest.removeHeaders("Connection");
                            httpRequest.removeHeaders("Cache-Control");
                            httpRequest.removeHeaders("Pragma");
                            httpRequest.removeHeaders("User-Agent");
                            httpRequest.removeHeaders("Referer");
                            /**
                             * Add common request headers
                             */
                            httpRequest.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
                            httpRequest.addHeader("Accept-Encoding", "gzip, deflate, sdch, br");
                            httpRequest.addHeader("Accept-Language", "en-US,en;q=0.8,ru;q=0.6,uk;q=0.4");
                            httpRequest.addHeader("Cache-Control", "no-cache");
                            httpRequest.addHeader("Connection", "keep-alive");
                            httpRequest.addHeader("Pragma", "no-cache");
                            httpRequest.addHeader("Upgrade-Insecure-Requests", "1");
                            httpRequest.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
                        }
                    })
                    .addInterceptorLast(new HttpResponseInterceptor() {
                        public void process(HttpResponse httpResponse, HttpContext httpContext) throws HttpException, IOException {
                            /**
                             * Adding of cookie from response to class-level local storage.
                             */
                            saveClientCookie(httpResponse);
                        }
                    });
        }
        this.httpClient = httpClientBuilder.build();
    }

    /**
     * Get Downloader instance
     *
     * @return
     */

    public static DownloadResourceHelper getDownloadResourceHelper(String propertyFileName) {
        return getDownloadResourceHelper(null, false, propertyFileName);
    }

    public static DownloadResourceHelper getDownloadResourceHelper(boolean autoRedirects, String propertyFileName) {
        return getDownloadResourceHelper(null, autoRedirects, propertyFileName);
    }

    public static DownloadResourceHelper getDownloadResourceHelper(File downloadPath, boolean autoRedirects, String propertyFileName) {
        if (singleInstance == null) {
            singleInstance = new DownloadResourceHelper(downloadPath, autoRedirects, propertyFileName);
        }
        return singleInstance;
    }

    /**
     * Extract header value from response
     *
     * @param response
     * @param name
     * @return
     */
    private String getResponseHeaderValue(HttpResponse response, String name) {
        Header header = response.getLastHeader(name);
        if (header == null) {
            return "";
        } else {
            return header.getValue();
        }
    }

    /**
     * Convert array to List
     *
     * @param objects
     * @return
     */
/*
    private <T> List<T> getListFromArray(T[] objects) {
        List<T> result = new ArrayList<T>();
        for (T c: objects) {
            if (c != null)
                result.add(c);
        }
        return result;
    }
*/

    /**
     * Return all saved client's cookies.
     *
     * @return
     */
    private List<Cookie> getAllStoredCookies() {
        List<Cookie> ckList = new ArrayList<>();
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            ckList.add(it.next());
        }
        return ckList;
    }

    /**
     * Get client cookie from local storage.
     *
     * @param name
     * @return
     */
    private Cookie getClientCookie(String name) {
        Cookie cookie = null;
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(name)) {
                cookie = c;
                break;
            }
        }
        return cookie;
    }

    /**
     * Class-level Cookie Storage.
     *
     * @param response
     */
    private void saveClientCookie(HttpResponse response) {
        Header[] chArray = response.getHeaders("Set-Cookie");
        if (chArray == null)
            return;

        List<Header> chList = Arrays.asList(chArray);
        for (Header header: chList) {
            boolean skipCookie = false;
            String nameValue = header.getValue().substring(0, header.getValue().indexOf(";"));
            Cookie newCookie = new BasicClientCookie(nameValue.split("=")[0], nameValue.split("=")[1]);

            Iterator<Cookie> it = this.localCookieStore.iterator();
            while (it.hasNext()) {
                Cookie c = it.next();
                if (c.getName().equalsIgnoreCase(newCookie.getName())) {
                    skipCookie = true;
                    continue;
                }
            }
            if (!skipCookie)
                this.localCookieStore.add(newCookie);
        }
    }

    /**
     * Add multiple cookies to response.
     *
     * @param request
     * @param cookies
     * @return
     */
    private HttpRequest setRequestCookies(HttpRequest request, List<Cookie> cookies) {
        if (cookies == null || cookies.isEmpty())
            return request;

        StringBuilder sb = new StringBuilder();
        for (Cookie c: cookies) {
            if (c != null) {
                if (sb.toString().length() != 0)
                    sb.append(";");
                sb.append(String.format("%s=%s", c.getName(), c.getValue()));
            }
        }
        if (sb.length() > 0)
            request.addHeader("Cookie", sb.toString());
        return request;
    }

    /**
     * Convert parameter's map to name-value format, for convenient usage for Apache's classes.
     *
     * @param params
     * @return
     */
    private List<NameValuePair> toMapNameValuePairs(Map<String, String> params) {
        List<NameValuePair> nvpList = new ArrayList<>();
        Iterator<Map.Entry<String, String>> it = params.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> entry = it.next();
            String name = entry.getKey();
            String value = entry.getValue();
            if (StringUtils.isNotBlank(name) && StringUtils.isNoneBlank(value))
                nvpList.add(new BasicNameValuePair(name, value));
        }
        return nvpList;
    }

    /**
     * Prepare GET request.
     *
     * @param url
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url) throws IOException, URISyntaxException {
        return prepareGet(url, null, null);
    }

    /**
     * Prepare GET request with adding multiple cookies.
     *
     * @param url
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, List<Cookie> cookies) throws IOException, URISyntaxException {
        return prepareGet(url, null, cookies);
    }

    /**
     * Prepare parametrised GET request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        if (params != null && !params.isEmpty()) {
            URIBuilder uriBuilder = new URIBuilder(url);
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            uriBuilder.addParameters(pairList);
            url = uriBuilder.toString();
        }
        HttpGet request = new HttpGet(url);
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Prepare parametrised POST request
     *
     * @param url
     * @param params
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params) throws IOException, URISyntaxException {
        return preparePost(url, params, null);
    }

    /**
     * Prepare parametrised POST request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        HttpPost request = new HttpPost(url);
        if (params != null && !params.isEmpty()) {
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            request.setEntity(new UrlEncodedFormEntity(pairList));
        }
        setRequestCookies(request, cookies);
        return request;
    }

    public String getDownloadPath() {
        return this.downloadPath.getPath();
    }

    /**
     * Return resource property value by it's name
     *
     * @param name
     * @return
     */
    public String getPropertyByName(String name) {
        return resourceProperties.getProperty(name);
    }

    /**
     * Load resource properties
     */
    public static Properties loadProps(String fileName) {
        Properties  resourceProperties = new Properties();
        if (StringUtils.isNotBlank(fileName)) {
            try {
                resourceProperties.load(new FileInputStream(fileName));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resourceProperties;
    }

    /*
     * FOR TRACING PURPOSES ONLY
     */
    private void debugStepNumber(int stepNum, String fileUrl) {
        debugStepNumber(stepNum, fileUrl, "GET");
    }
    private void debugStepNumber(int stepNum, String fileUrl, String requestMethod) {
        System.out.println(String.format("\nStep %d. %s url: %s", stepNum, requestMethod, fileUrl));
    }

    private <T extends  HttpRequest> void debugRequestHeaders(T request) {
        System.out.println("!!!!! Request headers:");
        List<Header> lHeader = Arrays.asList(request.getAllHeaders());
        for (Header h: lHeader) {
            System.out.println(String.format("\t%s: %s", h.getName(), h.getValue()));
        }
    }

    private void debugResponseHeaders(HttpResponse response) {
        debugResponseHeaders(response, null);
    }

    private <T extends HttpResponse> void debugResponseHeaders(T response, String responseBody) {
        System.out.println("\n!!!!! Response:");
        System.out.println("\tresponse.getStatusLine():" + response.getStatusLine());
        System.out.println("\tcontent-type:" + getResponseHeaderValue(response, "Content-Type"));
        System.out.println("\tlocation:" + getResponseHeaderValue(response, "Location"));
        System.out.println("\tset-cookie:");
        List<Header> listHeaders = Arrays.asList(response.getHeaders("Set-Cookie"));
        for (Header h: listHeaders) {
            System.out.println("\t\t" + h.getValue());
        }
        System.out.println("\tcontent-disposition:" + getResponseHeaderValue(response, "Content-Disposition"));
        if (StringUtils.isNotBlank(responseBody))
            System.out.println("\tresponseBody:" + responseBody);

        List<Header> lHeader = Arrays.asList(response.getAllHeaders());
        for (Header h: lHeader) {
            System.out.println(String.format("\t%s: %s", h.getName(), h.getValue()));
        }
    }
    /*
     * FOR TRACING PURPOSES ONLY
     */

    public String repeatableDownloadUmlsResourceManualProcessing(String fileUrl, String userName, String password, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadUmlsResourceManualProcessing(fileUrl, userName, password, fileName, packageDescription,true, NUMBER_OF_ATTEMPTS);
    }

    public String repeatableDownloadUmlsResourceWithRedirects(String fileUrl, String userName, String password, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadUmlsResourceWithRedirects(fileUrl, userName, password, fileName, packageDescription,true, NUMBER_OF_ATTEMPTS);
    }

    public String repeatableDownloadLoincResource(String fileUrl, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadLoincResource(fileUrl, fileName, packageDescription, true, NUMBER_OF_ATTEMPTS);
    }

    // Just login UMLS
    private boolean loginUmls(String loginUrl, String userName, String password) {
        CloseableHttpResponse response = null;
        try {
            HttpGet request = prepareGet(loginUrl);
            response = httpClient.execute(request);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                throw new HttpException(String.format("Unable to login UMLS service\n%s", response.getStatusLine()));
            } else
                return true;

        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    // Just download UMLS routine
    public String downloadUmlsResource(String fileUrl, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        debugStepNumber(5, fileUrl);

        CloseableHttpResponse response = null;
        OutputStream outputStream = null;
        HttpGet request = null;
        try  {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_MOD_AUTH_CAS));
            request = prepareGet(fileUrl, cookies);

            debugRequestHeaders(request);

            response = httpClient.execute(request);

            debugResponseHeaders(response);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries >= 0) {
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    return downloadUmlsResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();
            return fileName;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
            try {
                if (outputStream != null)
                    outputStream.close();
            } catch (IOException ioe) {}
        }
    }

    // Login and download resource
    public String downloadUmlsResourceManualProcessing(String fileUrl, String userName, String password, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        this.localCookieStore.clear();

        /*
         * REQUEST 1
         * Just get JSESSION cookie
         */
        debugStepNumber(1, fileUrl);
        this.ltParam = requestUmlsLoginTicket(fileUrl);

        /*
         * REQUEST 2
         * Login to UMLS
         */
        CloseableHttpResponse response = null;
        HttpPost postRequest = null;
        System.out.println("Login UMLS service...");
        debugStepNumber(2, fileUrl);
        try {
            Map<String, String> params = new HashMap<>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            postRequest = preparePost(fileUrl, params, cookies);
            postRequest.addHeader("Content-Type", "application/x-www-form-urlencoded");

            debugRequestHeaders(postRequest);

            response = httpClient.execute(postRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        /*
         * REQUEST 3
         * Authorize on download service with ticket
         */
        debugStepNumber(3, fileUrl);
        HttpGet getRequest= null;
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            cookies.add(getClientCookie(COOKIE_CASTGC));
            getRequest = prepareGet(fileUrl, cookies);

            debugRequestHeaders(getRequest);

            response = httpClient.execute(getRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            getRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        /*
         * REQUEST 4
         * Authorize on download service
         * Seems that this piece of code is redundant.
         */
/*
        debugStepNumber(4, fileUrl);
        if (getRequest != null)
            getRequest.reset();
        try {
            getRequest = prepareGet(fileUrl);

            debugRequestHeaders(getRequest);

            response = httpClient.execute(getRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            getRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
*/

        /*
         * REQUEST final
         * Download resource
         */
        return downloadUmlsResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
    }

    private String requestUmlsLoginTicket(String url) {
        CloseableHttpResponse response = null;
        HttpGet request = null;
        try {
            request = prepareGet(url);

            debugRequestHeaders(request);

            response = httpClient.execute(request);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Remember dynamically generated presumably "Login Ticket" form parameter
            Pattern ltPattern = Pattern.compile("name=\"lt\" value=\"(\\w+)\"");
            Matcher m = ltPattern.matcher(responseBody);
            String ltParam = StringUtils.EMPTY;
            while (m.find()) {
                ltParam = m.group(1);
            }
            return ltParam;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    public String downloadUmlsResourceWithRedirects(String fileUrl, String userName, String password, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        /*
         * REQUEST 1
         * Just get JSESSION cookie
         */
        debugStepNumber(1, fileUrl);
        this.ltParam = requestUmlsLoginTicket(fileUrl);

        /*
         * REQUEST 2
         * Login to UMLS and download package
         */
        CloseableHttpResponse response = null;
        OutputStream outputStream;
        HttpPost postRequest = null;
        System.out.println("Login UMLS service...");
        debugStepNumber(2, fileUrl, "POST");
        try {
            Map<String, String> params = new HashMap<>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            postRequest = preparePost(fileUrl, params);
            postRequest.addHeader("Content-Type", "application/x-www-form-urlencoded");

            debugRequestHeaders(postRequest);

            response = httpClient.execute(postRequest);

            debugResponseHeaders(response);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries >= 0) {
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....",
                            response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadUmlsResourceWithRedirects(fileUrl, userName, password, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();

        } catch (Exception e) {
            postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        return fileName;
    }

    public boolean loginLoinc(String loginUrl, String userName, String password) {
        CloseableHttpResponse response = null;
        HttpPost request = null;
        // Login LOINC services
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("log", userName);
            params.put("pwd", password);
            params.put("wp-submit", "Log In");
            request = preparePost(loginUrl, params);
            response = httpClient.execute(request);
            return true;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return false;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    public String downloadLoincResource(String fileUrl, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        OutputStream outputStream = null;
        CloseableHttpResponse response = null;
        HttpPost postRequest = null;
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("tc_accepted", "1");
            params.put("tc_submit", "Download");
            List<Cookie> cookies = getAllStoredCookies();
            postRequest = preparePost(fileUrl, params, cookies);
            response = httpClient.execute(postRequest);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries > 0) {
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadLoincResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            debugResponseHeaders(response);

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0) {
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            }
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();
            return fileName;

        } catch (Exception e) {
            if (postRequest != null)
                postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
            try {
                if (outputStream != null)
                    outputStream.close();
            } catch (IOException ioe) {}
        }
    }
}

/**
 * Created by Sanders on 5/26/2017.
 */
public class Xls2CsvHelper {

    public static final String CSV_FIELD_SEPARATOR = ";";

    private File convertPath;
    private static Xls2CsvHelper singleInstance;

    private Xls2CsvHelper() {
        this(null);
    }

    private Xls2CsvHelper(File convertPath) {
        if (convertPath == null || !convertPath.exists()) {
            this.convertPath = Files.createTempDir();
        } else
            this.convertPath = convertPath;
    }

    public static Xls2CsvHelper getXls2CsvHelper() {
        return getXls2CsvHelper(null);
    }

    public static Xls2CsvHelper getXls2CsvHelper(File convertPath) {
        if (singleInstance == null) {
            singleInstance = new Xls2CsvHelper(convertPath);
        }
        return singleInstance;
    }

    private String convertSheetByName(Workbook workbook) {
        return convertSheetByName(workbook, null, null);
    }

    private String normalizeString(String value) {
        String result = new String(value);
        // If empty - just return
        if (StringUtils.isBlank(value))
            return result;
        boolean doubleQuotesProcessed = false
        // Replace all number of double quotes by twice double quotes
        if (result.indexOf("\"") >= 0) {
            result = result.replaceAll("(\"{1,1})", "\"\"");
            doubleQuotesProcessed = true;
        }
        // Replace all double quotes by
        if (result.indexOf(CSV_FIELD_SEPARATOR) >= 0 || doubleQuotesProcessed) {
            result = String.format("\"%s\"", result);
        }
        // Replace all carriage return to space
        if (result.indexOf("\n") >= 0) {
            result = result.replaceAll("\n", " ");
        }
        // Replace all carriage return to space
        if (result.indexOf("\r") >= 0) {
            result = result.replaceAll("\r", " ");
        }
        // Replace the 'EN DASH' (U+2013) by the 'HYPHEN-MINUS' (U+002D)
        if (result.indexOf("\u2013") >= 0) {
            result = result.replaceAll("\u2013", "\u002D");
        }
        return result;
    }

    private String convertSheetByName(Workbook workbook, String name, String skipColumnsAfterName) {
        /**
         * Get Sheet by name of first sheet is name is not specified.
         */
        Sheet sheet = null;
        if (StringUtils.isNotBlank(name)) {
            for (int i = 0; i < workbook.getNumberOfSheets(); i++) {
                sheet = workbook.getSheetAt(i);
                if (sheet.getSheetName().equalsIgnoreCase(name)) {
                    break;
                }
            }
            if (sheet == null)
                throw new IllegalArgumentException(String.format("No Excel Sheet found for name: %s", name));
        } else
            sheet = workbook.getSheetAt(0);
        /**
         * Read data from cells
         */
        int skipColumnNumber = Integer.MAX_VALUE;
        StringBuffer data = new StringBuffer();
        for (int i = 0; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            boolean isCheckColumnsSkip = (i ==0 && StringUtils.isNotBlank(skipColumnsAfterName));
            if (row != null) {
                cell_loop:
                for (int j = 0; j < row.getLastCellNum(); j++) {
                    Cell cell = row.getCell(j);
                    if (cell == null) {
                        data.append(";");
                    } else {
                        cell.setCellType(Cell.CELL_TYPE_STRING);
                        String cellText = cell.toString().trim();
                        if (isCheckColumnsSkip  && cellText.equalsIgnoreCase(skipColumnsAfterName)) {
                            skipColumnNumber = j;
                        }
                        if (j <= skipColumnNumber) {
                            data.append(normalizeString(cellText));
                            if (j < skipColumnNumber && (j < row.getLastCellNum())) {
                                data.append(";");
                            }
                        } else
                            break cell_loop;
                    }
                }
                data.append('\n');
            }
        }
        return data.toString();
    }

    public void convertHcpcs(String inputFile, String outputFile) throws IllegalUpdateStateException, IOException {
        System.out.println("\n\tConversion of HCPCS data started");
        File f = new File(outputFile.substring(0, outputFile.lastIndexOf(File.separator) + 1));
        if (!f.exists()) {
            f.mkdir();
        } else {
            FileUtils.cleanDirectory(f);
        }
        /**
         * For storing data into CSV files
         */
        String data;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(outputFile);
            /**
             * Get the workbook object for XLS file
             */
            Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFile));
            /**
             * Get data from default (first) sheet and save to file
             */
            data = convertSheetByName(workbook);
            fos.write(data.getBytes(StandardCharsets.UTF_8));
            fos.flush();
            System.out.println("\tConversion of HCPCS data done");
        } catch (Exception e) {
            throw new IllegalUpdateStateException(e);
        } finally {
            try {
                if (fos != null)
                    fos.close();
            } catch (IOException ioe) {}
        }
    }

    public void convertLoinc(String inputFile, String destFolder, Map<String, String> sheetNameFilePathMap, Map<String, String> sheetNameSkiptColumnsAfterNameMap) throws IllegalUpdateStateException, IOException {
        System.out.println(new StringBuilderWrapper("Conversion of LOINC data started"));
        /**
         * Check if input Except file exists
         */
        File inputFileFullPath = new File(this.convertPath, inputFile);
        if (!inputFileFullPath.exists()) {
            throw new IOException(String.format("No input excel file found by name: %s", inputFileFullPath));
        }
        /**
         * Check output folder exists, if not - create it, otherwise - clean it
         */
        File outPath = new File(this.convertPath, destFolder);
        if (!outPath.exists()) {
            outPath.mkdir();
        } else {
            FileUtils.cleanDirectory(outPath);
        }

        String data;
        FileOutputStream fos = null;
        try {
            /**
             * Get the workbook object for XLS file
             */
            Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFileFullPath));

            Iterator<Map.Entry<String, String>> it = sheetNameFilePathMap.entrySet().iterator();
            while (it.hasNext()) {
                Map.Entry<String, String> sheetPathEntry = it.next();
                String sheetName = sheetPathEntry.getKey();
                String fileName = sheetPathEntry.getValue();
                String skipColumnsAfterName = sheetNameSkiptColumnsAfterNameMap.get(sheetName);
                /**
                 * Get data from first sheet "ANSWERS" and save to file
                 */
                data = convertSheetByName(workbook, sheetName, skipColumnsAfterName);

                File savedFilePath = new File(outPath, fileName);
                sheetPathEntry.setValue(savedFilePath);
                System.out.println(new StringBuilderWrapper(String.format("Conversion of Sheet '%s' done. Saved to: '%s'.", sheetName, savedFilePath.getPath())));
                fos = new FileOutputStream(savedFilePath);
                fos.write(data.getBytes(StandardCharsets.UTF_8));
                fos.flush();
            }
            System.out.println(new StringBuilderWrapper("Conversion of LOINC data done"));
        } catch (Exception e) {
            throw new IllegalUpdateStateException(e);
        } finally {
            try {
                if (fos != null)
                    fos.close();
            } catch (IOException ioe) {}
        }
    }
    
    public String getNormalizedCsvFile(String filePath, String fieldSeparator) {
        File srcFile = new File(filePath);
        if (!srcFile.exists())
            return filePath;
        try {
            BufferedReader bufferedReader = new BufferedReader(new FileReader(srcFile));

            File tempFile = File.createTempFile(srcFile.getName(), "tmp");
            BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(tempFile));

            String stringLine;
            while ((stringLine = bufferedReader.readLine()) != null) {
                List<String> normalizedStringLineList = new ArrayList<>();
                List<String> stringLineList = Arrays.asList(stringLine.split(fieldSeparator));
                for (String s: stringLineList) {
                    normalizedStringLineList.add(normalizeString(s));
                }

                String normalizedStringLine = String.join(fieldSeparator, normalizedStringLineList);
                bufferedWriter.write(normalizedStringLine + "\r\n");
                bufferedWriter.flush();
            }
            return tempFile.getPath();

        } catch (Exception e) {
            e.printStackTrace();
            return filePath;
        }
    }

    private static boolean fileHasExtension(String fileName, List<String> extensionList) {
        if (extensionList == null || StringUtils.isBlank(fileName))
            return false;
        String fName = fileName.toLowerCase();
        for (String ext: extensionList) {
            if (fName.endsWith(ext.toLowerCase()))
                return true;
        }
        return false;
    }

    public static List<File> getFilesByName(File folder, String nameTemplate, boolean strictSearch) throws IllegalUpdateStateException {
        return getFilesByName(folder, nameTemplate, Collections.EMPTY_LIST, strictSearch);
    }

    public static List<File> getFilesByName(File folder, String nameTemplate, String excludeExtension, boolean strictSearch) throws IllegalUpdateStateException {
        return getFilesByName(folder, nameTemplate, Arrays.asList(excludeExtension), strictSearch);
    }

    public static List<File> getFilesByName(File folder, String nameTemplate, List<String> excludeExtensionList, boolean strictSearch) throws IllegalUpdateStateException {
        File[] matchedFiles = folder.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.toLowerCase().indexOf(nameTemplate.trim().toLowerCase()) >= 0 &&
                        !fileHasExtension(name, excludeExtensionList);
            }
        });
        List<File> foundFiles = Arrays.asList(matchedFiles);

        if (strictSearch) {
            if (foundFiles.isEmpty())
                throw new IllegalUpdateStateException(String.format("No file found by name: %s", nameTemplate));
            else if (foundFiles.size() > 1)
                throw new IllegalUpdateStateException(String.format("More than one files found by name: %s", nameTemplate));
        }
        return foundFiles;
    }

    public static String copy(String from, String to) throws IOException {
        Path copyFrom = Paths.get(from);
        Path copyTo = Paths.get(to);
        Path targetFile = java.nio.file.Files.copy(copyFrom, copyTo, StandardCopyOption.REPLACE_EXISTING);
        return targetFile.normalize().toString();
    }
}
/**
 * Auxiliary classes. TODO: Further should be used java-defined and compiled only
 */
public class StringBuilderWrapper implements java.lang.Appendable {
    private static final String IDENT_CHAR = " " *4
    private StringBuilder wrapped

    public StringBuilderWrapper() {
        wrapped = new StringBuilder()
    }
    public StringBuilderWrapper(String value) {
        this()
        wrapped.append(IDENT_CHAR).append(value)
    }

    public static StringBuilderWrapper getBuilder() {
        return new StringBuilderWrapper()
    }

    public static String readFromFile(File file) {
        if (file == null)
            return ''
        def builder = getBuilder()
        def br = new BufferedReader(new FileReader(file))
        def strLine
        while ((strLine = br.readLine()) != null) {
                builder.append('\n').append(strLine)
        }
        return builder.toString()
    }

    @Override
    Appendable append(CharSequence csq) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq)
        return this
    }
    @Override
    Appendable append(CharSequence csq, int start, int end) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq, start, end)
        return this
    }
    @Override
    Appendable append(char c) throws IOException {
        wrapped.append(IDENT_CHAR).append(c)
        return this
    }
    @Override
    String toString() {
        return wrapped.toString()
    }
}

/**
 * JAVA-CODE SECTION
 */

// Load LOINC properties
Properties props = new Properties()
props.load(new FileInputStream("${project.getBuildFile().toString().replace('.gradle', '.properties')}"))
props.each {prop ->
    project.ext.set(prop.key, prop.value)
}

def tempDir = File.createTempDir()
tempDir.deleteOnExit()

/**
 * Just renew user schema and prepare it for further vocabulary update
 */
task fastRecreateSchema(description: project.properties['fastRecreate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*       '${description}' action started...     *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['fastRecreate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['fastRecreate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus -L ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))
    
    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will prepare user schema for vocabulary update routine.
 * It will create auxiliary tables - the "ICD10CM_TABLE","LOINC","MAP_TO","SOURCE_ORGANIZATION","LOINC_ANSWERS","LOINC_FORMS","LOINC_CLASS","CPT_MRSMAP","scccRefset_MapCorrOrFull_INT" in our case, for example.
 */
task createSourceTable(/*dependsOn: fastRecreateSchema, */description: project.properties['createSourceTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*   '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['createSourceTable.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['createSourceTable.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task which will download vocabulary update package from source host.
 * There are many URLs (in see the https://github.com/OHDSI/Vocabulary-v5.0/blob/master/LOINC/readme.md for details)
 */
task downloadUpdatePack(dependsOn: createSourceTable, description: project.properties['downloadUpdatePack.description']) << {
    println '\n\n*******************************************************'
    println '*                                                     *'
    println "*    '${description}' action started...     *"
    println '*                                                     *'
    println '*******************************************************'

    /* Downloading file */
    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    DownloadResourceHelper downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(tempDir, true, "${project.getBuildFile().toString().replace('.gradle', '.properties')}");

    // Login LOINC service
    println "\n${new StringBuilderWrapper("Login LOINC service...")}"
    String loginUrl = project.properties['downloadUpdatePack.loinc.loginUrl']
    String userName = project.properties['downloadUpdatePack.loinc.username']
    String password = project.properties['downloadUpdatePack.loinc.password']
    downloadHelper.loginLoinc(loginUrl, userName, password)

    /*************************************************
     * Download 'Full Set' package (from LOINC portal)
     * **********************************************/
    String packageDescription = project.properties['downloadUpdatePack.fullSet.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    String fileUrl = project.properties['downloadUpdatePack.fullSet.fileUrl']
    String defaultFileName = project.properties['downloadUpdatePack.fullSet.fileName']
    String downloadedFileName = downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.fullSet.fileName', downloadedFileName);

    /*************************************************************
     * Download 'Multiaxial Hierarchy' package (from LOINC portal)
     * ***********************************************************/
    packageDescription = project.properties['downloadUpdatePack.multiaxialHierarchy.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.multiaxialHierarchy.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.multiaxialHierarchy.fileName', downloadedFileName);

    /*********************************************************
     * Download 'Panels and Forms' package (from LOINC portal)
     * *******************************************************/
    packageDescription = project.properties['downloadUpdatePack.panelsForms.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.panelsForms.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.panelsForms.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.panelsForms.fileName', downloadedFileName);

    /******************************************************************
     * Download 'CT Expression Association' package (from LOINC portal)
     * ****************************************************************/
    packageDescription = project.properties['downloadUpdatePack.expressionAssociation.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
    fileUrl = project.properties['downloadUpdatePack.expressionAssociation.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.expressionAssociation.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription)
    project.ext.set('downloadUpdatePack.expressionAssociation.fileName', downloadedFileName);

    /****************************************************
     * Download 'CPT Mappings' package (from UMLS portal)
     * **************************************************/
    packageDescription = project.properties['downloadUpdatePack.cptMappings.description']
    println "\n${new StringBuilderWrapper("Downloading ${packageDescription}...")}"
//    loginUrl = project.properties['downloadUpdatePack.umls.loginUrl']
    userName = project.properties['downloadUpdatePack.umls.username']
    password = project.properties['downloadUpdatePack.umls.password']
    fileUrl = project.properties['downloadUpdatePack.cptMappings.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.cptMappings.fileName']
    downloadedFileName = downloadHelper.repeatableDownloadUmlsResourceWithRedirects(fileUrl, userName, password, defaultFileName, packageDescription);
    project.ext.set('downloadUpdatePack.cptMappings.fileName', downloadedFileName);

    println "\n${new StringBuilderWrapper('Download completed.')}"
    println "${new StringBuilderWrapper("Update packages are saved to the: ${tempDir.getPath()}")}"

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

task extractFiles(dependsOn: downloadUpdatePack, description: project.properties['extractFiles.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /* Extracting file */
    def fileList = []
    def dir = tempDir
    dir.eachFile(FileType.FILES) { file ->
        fileList << file
        if (file.getPath().endsWith('zip')) {
            print new StringBuilderWrapper("Extracting ${file} ...")
            ant.unzip(src: file.getPath(), dest: tempDir, overwrite: false)
            println ' done'
        }
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will com.odysseusinc.convert a XLS data file to CSV format.
 */
task convertData(dependsOn: extractFiles, description: project.properties['convertData.description']) << {
    println '\n\n*************************************************'
    println '*                                               *'
    println "*  '${description}' action started...  *"
    println '*                                               *'
    println '*************************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    Xls2CsvHelper convertHelper = Xls2CsvHelper.getXls2CsvHelper(tempDir)

    try {
        Map<String, String> sheetNameFilePathMap = new HashMap<String, String>()
        sheetNameFilePathMap.put("ANSWERS", project.properties['convertData.panelsForms.answers.destFileName'])
        sheetNameFilePathMap.put("FORMS", project.properties['convertData.panelsForms.forms.destFileName'])

        Map<String, String> sheetNameSkiptColumnsAfterNameMap = new HashMap<String, String>()
        sheetNameSkiptColumnsAfterNameMap.put("ANSWERS", "DisplayText")
        sheetNameSkiptColumnsAfterNameMap.put("FORMS", "Loinc")

        String fileNameTemplate = "panelsandforms"
        List<File> fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, Arrays.asList("zip", "txt"), true)
        String inputFile = fileList.get(0).getName()
        String importReadyFolder = "ready_for_import"
        convertHelper.convertLoinc(inputFile, importReadyFolder, sheetNameFilePathMap, sheetNameSkiptColumnsAfterNameMap)

        /**
         * Prepare all other files for import
         */
        String answersCsvFile = sheetNameFilePathMap.get("ANSWERS")
        project.ext.set("importData.panelsForms.answers.dataFileName", answersCsvFile)

        String formsCsvFile = sheetNameFilePathMap.get("FORMS")
        project.ext.set("importData.panelsForms.forms.dataFileName", formsCsvFile)

        String targetPath = new File(tempDir, importReadyFolder).getPath()

        fileNameTemplate = "loinc.csv"
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true)
        String fileToCopy = fileList.get(0).getName()
        println "\n${new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}")}"
        String loincCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        )
        project.ext.set("importData.fullSet.loinc.dataFileName", loincCsvFile)

        fileNameTemplate = "map_to.csv"
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true)
        fileToCopy = fileList.get(0).getName()
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}")
        String mapToCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        )
        project.ext.set("importData.fullSet.mapTo.dataFileName", mapToCsvFile)

        fileNameTemplate = "source_organization.csv"
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true)
        fileToCopy = fileList.get(0).getName()
        // Normalize CSV file data
        File filePath = new File(tempDir, fileToCopy);
        println new StringBuilderWrapper("Normalize file: '${filePath.getPath()}'")
        String normalizedFilePath = convertHelper.getNormalizedCsvFile(filePath.getPath(), ",");
        // Copy normalized CSV file
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}")
        String sourceOrganizationCsvFile = convertHelper.copy(
                new File(normalizedFilePath).getPath(),
                new File(targetPath, fileToCopy).getPath()
        )
        project.ext.set("importData.fullSet.sourceOrganization.dataFileName", sourceOrganizationCsvFile)

        fileToCopy = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName'].replaceAll(".zip", ".csv")
        fileNameTemplate = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName'].toString()
        fileNameTemplate = fileNameTemplate.substring(0, fileNameTemplate.lastIndexOf("."))
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, "zip", true)
        fileToCopy = fileList.get(0).getName()
        String multiaxialHierarchyCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        )
        project.ext.set("importData.multiaxialHierarchy.dataFileName", multiaxialHierarchyCsvFile)

        filePath = new File(project.properties['downloadUpdatePack.expressionAssociation.fileName'].replaceAll(".zip", "")
                ,"Full/Refset/Content")
        filePath = new File(tempDir, filePath.getPath())

        fileNameTemplate = "xder2_sscccRefset_LOINCExpressionAssociationFull_INT";
        fileList = convertHelper.getFilesByName(filePath, fileNameTemplate, true);
        fileToCopy = fileList.get(0).getName();
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}");
        String expressionAssociationCsvFile = convertHelper.copy(
                new File(filePath, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        );
        project.ext.set("importData.expressionAssociation.dataFileName", expressionAssociationCsvFile)

        fileNameTemplate = "MRSMAP"
        fileList = convertHelper.getFilesByName(tempDir, fileNameTemplate, true)
        fileToCopy = fileList.get(0).getName()
        println new StringBuilderWrapper("Copy from: '${new File(tempDir, fileToCopy).getPath()}',\n\t to ${targetPath}")
        String cptMappingsCsvFile = convertHelper.copy(
                new File(tempDir, fileToCopy).getPath(),
                new File(targetPath, fileToCopy).getPath()
        )
        project.ext.set("importData.cptMappings.dataFileName", cptMappingsCsvFile)

    } catch (Exception e) {
        e.printStackTrace();
        throw new GradleException(String.format(project.properties['error.message'], e.getMessage(), name))
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task performed import CSV data to database
 */
task importData(dependsOn: convertData, description: project.properties['importData.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*         '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /**
     * Filter import-specific parameters
     */
    Map<String, String> importParams = project.properties.findAll {
        it.getKey().startsWith("importData.") && it.getKey().toLowerCase().indexOf("description") < 0
    }
    /**
     * Group import-specific parameters
     */
    Map<String, String> importParamsGrouped = importParams.groupBy {it.getKey().substring(0, it.getKey().lastIndexOf("."))}

    /**
     * Process import
     */
    Iterator<Map.Entry<?, ?>> importIterator = importParamsGrouped.entrySet().iterator()
    while(importIterator.hasNext()) {
        Map.Entry<?, ?> importEntry = importIterator.next()
        String groupNameLabel = importEntry.getKey().replaceAll("\\.", " ").capitalize()
        Map<String, String> groupParams = importEntry.getValue()
        
        String controlFileName = groupParams.find {it.getKey().toLowerCase().indexOf("controlFileName".toLowerCase()) >= 0}.getValue()
        String dataFileName = groupParams.find {it.getKey().toLowerCase().indexOf("dataFileName".toLowerCase()) >= 0}.getValue()
        String logFileName = groupParams.find {it.getKey().toLowerCase().indexOf("logFileName".toLowerCase()) >= 0}.getValue()
        String discardFileName = groupParams.find {it.getKey().toLowerCase().indexOf("discardFileName".toLowerCase()) >= 0}.getValue()
        String badFileName = groupParams.find {it.getKey().toLowerCase().indexOf("badFileName".toLowerCase()) >= 0}.getValue()
        String streamLogFileName = groupParams.find {it.getKey().toLowerCase().indexOf("streamLogFileName".toLowerCase()) >= 0}.getValue()
        String streamErrorFileName = groupParams.find {it.getKey().toLowerCase().indexOf("streamErrorFileName".toLowerCase()) >= 0}.getValue()

        Map.Entry<String, String> providedEntry = groupParams.find {it.getKey().toLowerCase().indexOf("provided".toLowerCase()) >= 0}
        boolean provided = false
        if (providedEntry != null) {
            provided = Boolean.valueOf(providedEntry.getValue()).booleanValue()
        }
        if (provided) {
            dataFileName = new File(project.properties['basePath'], dataFileName).getPath()
        }

        println "\n${new StringBuilderWrapper("${groupNameLabel}...")}"
        
        def bosOut = new ByteArrayOutputStream(), bosErr = new ByteArrayOutputStream()
        def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
        exec {
            executable "sqlldr"
            args "USERID=${project.properties['db.userName']}/${project.properties['db.password']}@${project.properties['db.tnsName']} " +
                 "CONTROL=${project.properties['basePath']}/${controlFileName} " +
                 "DATA=${dataFileName} " +
                 "LOG=${project.properties['logPath']}/${logFileName} " +
                 "DISCARD=${project.properties['logPath']}/${discardFileName} " +
                 "BAD=${project.properties['logPath']}/${badFileName}"
            standardOutput = bosOut
            errorOutput = bosErr
        }
        def bisOut = new ByteArrayInputStream(bosOut.toByteArray())
        bisOut.withReader { out->
            out.eachLine {
                sOut.append(it).append('\n')
            }
        }
        def bisErr = new ByteArrayInputStream(bosErr.toByteArray())
        bisErr.withReader { out ->
            out.eachLine {
                sErr.append(it).append('\n')
            }
        }

        /**
         *  Write to console.
         *  When import prefer to write stream log to console (it's shorter).
         */
        System.out.println(sOut.toString())

        // Write to logfile
        File f = new File("${project.properties['logPath']}/${streamLogFileName}")
        f.write(sOut.toString())

        // Write to error file
        f = new File("${project.properties['logPath']}/${streamErrorFileName}")
        f.write(sErr.toString())
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Load stage' script.
 * Seems it's is specific for each vocabulary.
 */

task loadStage(dependsOn: importData, description: project.properties['loadStage.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['loadStage.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['loadStage.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['loadStage.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['loadStage.streamErrFileName']}"
    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}
/**
 * This task will run 'Genetic update' script.
 * It's common for all updated vocabularies and located in '\Vocabulary-v5.0\working\generic_update.sql' file.
 */
task genericUpdate(dependsOn: loadStage, description: project.properties['genericUpdate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*     '${description}' action started...      *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['genericUpdate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['genericUpdate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run scripts which allows to see the vocabulary update results
 */
task checkUpdateResults(dependsOn: genericUpdate, description: project.properties['checkUpdateResults.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*  '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['checkUpdateResults.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to log file
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Bootstrap action
 *
 * TODO: Needs to find solution to measure whole task chain execution.
 * TODO: This one via doFirst/doLast actions isn't working.
 */
task startUpdate(dependsOn: checkUpdateResults, description: project.properties['startUpdate.description']) {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*      '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema...\n"

    project.ext['logPath'] = "${project.properties['basePath']}/${project.properties['baseLogPath']}"
    def folder = new File(project.properties['logPath'])
    if (!folder.exists()) {
        folder.mkdirs()
        println "Log directory is created: ${folder.getPath()}"
    } else {
        FileUtils.cleanDirectory(folder)
        println "Log directory is cleaned: ${folder.getPath()}"
    }

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    doLast {
        // Finish action checkpoint
        def timeFinish = System.currentTimeMillis()

        // Measure time execution
        def timeElapsed = (timeFinish - timeStart) / 1000
        println "\n\nTotal time elapsed: ${timeElapsed} seconds."
        println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema is completed successfully..."
        println '***********************************************'
        println '*                                             *'
        println "*      '${description}' action is done...       *"
        println '*                                             *'
        println '***********************************************\n'
    }
}