/*
****************************
* LOINC Vocabulary update  *
* Version 0.0.6            *
****************************
*/

group 'com.sci.vocabulary'
version '1.0-SNAPSHOT'

apply plugin: 'java'

apply plugin: 'groovy'

sourceCompatibility = 1.8

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'org.apache.poi:poi:3.9'
        classpath 'org.apache.poi:poi-ooxml:3.9'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.codehaus.groovy.modules.http-builder:http-builder:0.5.2'
        classpath 'com.squareup.okhttp3:okhttp:3.5.0'

        classpath 'commons-io:commons-io:2.5'
        classpath 'org.apache.httpcomponents:httpclient:4.5.3'
        classpath 'org.apache.httpcomponents:httpcore:4.4.6'
        classpath 'commons-httpclient:commons-httpclient:3.1'
        classpath 'commons-io:commons-io:2.5'

        classpath 'org.apache.commons:commons-lang3:3.5'
        classpath 'com.google.guava:guava:21.0'

        classpath group: 'commons-io', name: 'commons-io', version: '2.5'
    }
}
/*
repositories {
    mavenLocal()
    mavenCentral()
}
dependencies {
    classpath 'org.apache.poi:poi:3.9'
    classpath 'org.apache.poi:poi-ooxml:3.9'
}

*/

import groovy.io.FileType
import org.apache.poi.ss.usermodel.Cell
import org.apache.poi.ss.usermodel.Row
import org.apache.poi.ss.usermodel.Workbook
import org.apache.poi.ss.usermodel.WorkbookFactory
import org.apache.poi.ss.usermodel.Sheet

/*
task compileOne(type: JavaCompile) {
    source = sourceSets.main.java.srcDir
    include 'inc.odysseus.utils/StringBuilderWrapper.java'
    classpath = sourceSets.main.output.classesDir
    destinationDir = sourceSets.main.output.classesDir
}
compileOne.options.compilerArgs = ["-sourcepath", "${projectDir}/src/main/java"]

*/
/**
 * JAVA-CODE SECTION.
 * 
 * Temporary java code are located here. If future it's need to move it toi separate java-module.
 */

import com.google.common.base.Joiner;
import com.google.common.io.Files;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.FileUtils
import org.apache.http.HttpException;
import org.apache.http.HttpResponse;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponseInterceptor;
import org.apache.http.HttpRequestInterceptor;
import org.apache.http.NameValuePair;
import org.apache.http.Header;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.cookie.Cookie;
import org.apache.http.entity.BufferedHttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.cookie.BasicClientCookie;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.protocol.HttpContext;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.http.Consts;
import org.apache.http.util.EntityUtils;

import java.io.*;
import java.net.URISyntaxException;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by Sanders on 5/23/2017.
 */

public class DownloadResourceHelper {
    /**
     * Names of using cookies.
     *
     * COOKIE_JSESSIONID - session identifier on UMLS login service;
     * COOKIE_CASTGC - client authentication cookie for UMLS login service;
     * COOKIE_MOD_AUTH_CAS - client ticket-authentication cookie for UMLS download service.
     */
    public static final String COOKIE_JSESSIONID = "JSESSIONID";
    public static final String COOKIE_CASTGC = "CASTGC";
    public static final String COOKIE_MOD_AUTH_CAS = "MOD_AUTH_CAS";

    private CloseableHttpClient httpClient;
    private File downloadPath;
    /**
     * Presumably "Login Ticket" parameter.
     * Used on user form during authentication, generated by UMLS login service when new session is created.
     */
    private String ltParam;

    /**
     * Class-level cookie store
     */
    private List<Cookie> localCookieStore;

    /**
     * Apache CookieStore for all cookies.
     * Isn't used because of using class-level cookie store.
     */
//    private CookieStore cookieStore;

    /**
     * Instance of Download Helper.
     */
    private static DownloadResourceHelper singleIntance;

    /**
     * Contructor
     */
        private DownloadResourceHelper() {
            this(null);
        }

        private DownloadResourceHelper(File downloadPath) {
            if (downloadPath == null || !downloadPath.exists()) {
                // Prepare temporary storage for content
                this.downloadPath = Files.createTempDir();
                this.tempDir.deleteOnExit();
            } else {
                this.downloadPath = downloadPath;
            }

            this.localCookieStore = new ArrayList<Cookie>();

            // Create HttpClient
            this.httpClient = HttpClients.custom()
                    .disableCookieManagement()
                    .disableRedirectHandling()
                    .addInterceptorLast(new HttpRequestInterceptor() {
                public void process(HttpRequest httpRequest, HttpContext httpContext) throws HttpException, IOException {
                    /**
                     * Add common request headers
                     */
                    httpRequest.addHeader("Connection", "keep-alive");
                    httpRequest.addHeader("Upgrade-Insecure-Requests", "1");
                    httpRequest.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");
                    httpRequest.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
                    httpRequest.addHeader("Accept-Encoding", "gzip, deflate, sdch, br");
                    httpRequest.addHeader("Accept-Language", "en-US,en;q=0.8,ru;q=0.6,uk;q=0.4");
                    httpRequest.addHeader("Cache-Control", "no-cache");
                    httpRequest.addHeader("Pragma", "no-cache");
                }
            }).addInterceptorLast(new HttpResponseInterceptor() {
                public void process(HttpResponse httpResponse, HttpContext httpContext) throws HttpException, IOException {
                    /**
                     * Adding of cookie from response to class-level local storage.
                     */
                    saveClientCookie(httpResponse);
                }
            }).build();
    }

    /**
     * Extract header value from response
     *
     * @param response
     * @param name
     * @return
     */
    private String getResponseHeaderValue(HttpResponse response, String name) {
        Header header = response.getLastHeader(name);
        if (header == null) {
            return "";
        } else {
            return header.getValue();
        }
    }

    /**
     * Convert array to List
     *
     * @param objects
     * @return
     */
    private <T> List<T> getListFromArray(T[] objects) {
        List<T> result = new ArrayList<T>();
        for (T c: objects) {
            if (c != null) {
                result.add(c);
            }
        }
        return result;
    }

    /**
     * Return all saved client's cookies.
     *
     * @return
     */
    private List<Cookie> getAllStoredCookies() {
        List<Cookie> ckList = new ArrayList<Cookie>();
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            ckList.add(it.next());
        }
        return ckList;
    }

    /**
     * Get client cookie from local storage.
     *
     * @param name
     * @return
     */
    private Cookie getClientCookie(String name) {
        Cookie cookie = null;
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(name)) {
                cookie = c;
                break;
            }
        }
        return cookie;
    }

    /**
     * Class-level Cookie Storage.
     *
     * @param request
     */
    private void saveClientCookie(HttpResponse request) {
        Header cookieHeader = request.getLastHeader("Set-Cookie");
        if (cookieHeader == null)
            return;
        String nameValue = cookieHeader.getValue().substring(0, cookieHeader.getValue().indexOf(";"));
        Cookie newCookie = new BasicClientCookie(nameValue.split("=")[0], nameValue.split("=")[1]);

        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(newCookie.getName()))
                return;
        }
        this.localCookieStore.add(newCookie);
    }

    /**
     * Add multiple cookies to response.
     *
     * @param request
     * @param cookies
     * @return
     */
    private HttpRequest setRequestCookies(HttpRequest request, List<Cookie> cookies) {
        if (cookies == null || cookies.isEmpty())
            return request;

        StringBuilder sb = new StringBuilder();
        for (Cookie c: cookies) {
            if (sb.toString().length() != 0)
                sb.append(";");
            sb.append(String.format("%s=%s", c.getName(), c.getValue()));
        }
        request.addHeader("Cookie", sb.toString());
        return request;
    }

    /**
     * Convert parameter's map to name-value format, for convenient usage for Apache's classes.
     *
     * @param params
     * @return
     */
    private List<NameValuePair> toMapNameValuePairs(Map<String, String> params) {
        List<NameValuePair> nvpList = new ArrayList<NameValuePair>();
        Iterator<Map.Entry<String, String>> it = params.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> entry = it.next();
            String name = entry.getKey();
            String value = entry.getValue();
            if (StringUtils.isNotBlank(name) && StringUtils.isNoneBlank(value))
                nvpList.add(new BasicNameValuePair(name, value));
        }
        return nvpList;
    }

    /**
     * Prepare GET request.
     *
     * @param url
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url) throws IOException, URISyntaxException {
        return prepareGet(url, null, null);
    }

    /**
     * Prepare GET request with adding multiple cookies.
     *
     * @param url
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, List<Cookie> cookies) throws IOException, URISyntaxException {
        return prepareGet(url, null, cookies);
    }

    /**
     * Prepare parametrised GET request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        if (params != null && !params.isEmpty()) {
            URIBuilder uriBuilder = new URIBuilder(url);
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            uriBuilder.addParameters(pairList);
            url = uriBuilder.toString();
        }
        HttpGet request = new HttpGet(url);
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Prepare parametrised POST request
     *
     * @param url
     * @param params
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params) throws IOException, URISyntaxException {
        return preparePost(url, params, null);
    }

    /**
     * Prepare parametrised POST request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        HttpPost request = new HttpPost(url);
        if (params != null && !params.isEmpty()) {
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            request.setEntity(new UrlEncodedFormEntity(pairList));
        }
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Get instance
     *
     * @return
     */
    public static DownloadResourceHelper getDownloadResourceHelper(File downloadPath) {
        if (singleIntance == null) {
            singleIntance = new DownloadResourceHelper(downloadPath);
        }
        return singleIntance;
    }

    // Login and download resource
    public boolean downloadResourceUmls(String loginUrl, String userName, String password, String fileUrl, String fileName) throws IOException {
        CloseableHttpResponse response = null;
        // REQUEST 1
        // Just to get first JSESSION cookie
        try {
            HttpGet request = prepareGet(loginUrl);
            response = httpClient.execute(request);

            // Remember dynamically generated presumably "Login Ticket" form parameter
            String responseBody = EntityUtils.toString(response.getEntity()).trim();
            Pattern ltPattern = Pattern.compile("name=\"lt\" value=\"(\\w+)\"");
            Matcher m = ltPattern.matcher(responseBody);
            while (m.find()) {
                this.ltParam = m.group(1);
            }
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }
        }

        // REQUEST 2
        // Login
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            HttpPost request = preparePost(loginUrl, params, cookies);
            request.addHeader("Content-Type", "application/x-www-form-urlencoded");
            response = httpClient.execute(request);

        } catch (Exception e) {
            System.out.println("Exception occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 3
        // Get ticket for requested resource
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            cookies.add(getClientCookie(COOKIE_CASTGC));
            HttpGet request = prepareGet(fileUrl, cookies);
            response = httpClient.execute(request);

            /**
             * Get URL for further processing
             */
            fileUrl = getResponseHeaderValue(response, "Location");
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 4
        // Authorize on download service
        try {
            HttpGet request = prepareGet(fileUrl);
            response = httpClient.execute(request);

            /**
             * Get URL for further processing
             */
            fileUrl = getResponseHeaderValue(response,"Location");
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (response != null)
                response.close();
        }

        // REQUEST 5
        // Download resource
        OutputStream outputStream = null;
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_MOD_AUTH_CAS));
            HttpGet request = prepareGet(fileUrl, cookies);
            response = httpClient.execute(request);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, Consts.UTF_8);

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(new StringBuilderWrapper(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength)));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copy(bufEntity.getContent(), outputStream);
            outputStream.flush();
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }

            if (outputStream != null) {
                outputStream.close();
            }
        }
        return true;
    }

    public boolean loginLoinc(String loginUrl, String userName, String password) throws IOException {
        CloseableHttpResponse response = null;
        // Login LOINC services
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("log", userName);
            params.put("pwd", password);
            params.put("wp-submit", "Log In");
            HttpPost request = preparePost(loginUrl, params);
            response = httpClient.execute(request);

            return true;
        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
            return false;
        } finally {
            if (response != null) {
                response.close();
            }
        }
    }

    public void downloadResourceLoinc(String fileUrl, String fileName, String packageDescription) throws IOException {
        OutputStream outputStream = null;
        CloseableHttpResponse response = null;
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("tc_accepted", "1");
            params.put("tc_submit", "Download");
            List<Cookie> cookies = getAllStoredCookies();
            HttpPost request = preparePost(fileUrl, params, cookies);
            response = httpClient.execute(request);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                throw new HttpException(String.format("Unable to download %s", packageDescription));
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%ы is not a ZIP archive", packageDescription));
            }

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, Consts.UTF_8);
            String responseBody = writer.toString().trim();

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0) {
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            }
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copy(bufEntity.getContent(), outputStream);
            outputStream.flush();

        } catch (Exception e) {
            System.out.println("Error occurs: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (response != null) {
                response.close();
            }
            if (outputStream != null) {
                outputStream.close();
            }
        }
    }
}

/**
 * Auxiliary classes. TODO: Further should be used java-defined and compiled only
 */
public class StringBuilderWrapper implements java.lang.Appendable {
    private static final String IDENT_CHAR = " " *4
    private StringBuilder wrapped

    public StringBuilderWrapper() {
        wrapped = new StringBuilder()
    }
    public StringBuilderWrapper(String value) {
        this()
        wrapped.append(IDENT_CHAR).append(value)
    }

    public static StringBuilderWrapper getBuilder() {
        return new StringBuilderWrapper()
    }

    public static String readFromFile(File file) {
        if (file == null)
            return ''
        def builder = getBuilder()
        def br = new BufferedReader(new FileReader(file))
        def strLine
        while ((strLine = br.readLine()) != null) {
                builder.append('\n').append(strLine)
        }
        return builder.toString()
    }

    @Override
    Appendable append(CharSequence csq) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq)
        return this
    }
    @Override
    Appendable append(CharSequence csq, int start, int end) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq, start, end)
        return this
    }
    @Override
    Appendable append(char c) throws IOException {
        wrapped.append(IDENT_CHAR).append(c)
        return this
    }
    @Override
    String toString() {
        return wrapped.toString()
    }
}

// Load LOINC properties
Properties props = new Properties()
props.load(new FileInputStream("${project.getBuildFile().toString().replace('.gradle', '.properties')}"))
props.each {prop ->
    project.ext.set(prop.key, prop.value)
}

def tempDir = File.createTempDir()
tempDir.deleteOnExit()

/**
 * Just renew user schema and prepare it for further vocabulary update
 */
task fastRecreateSchema(description: project.properties['fastRecreate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*       '${description}' action started...     *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['fastRecreate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['fastRecreate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}
/**
 * JAVA-CODE SECTION
 */

/**
 * This task will prepare user schema for vocabulary update routine.
 * It will create auxiliary tables - the "ICD10CM_TABLE","LOINC","MAP_TO","SOURCE_ORGANIZATION","LOINC_ANSWERS","LOINC_FORMS","LOINC_CLASS","CPT_MRSMAP","scccRefset_MapCorrOrFull_INT" in our case, for example.
 */
task createSourceTable(dependsOn: fastRecreateSchema, description: project.properties['createSourceTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*   '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['createSourceTable.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['createSourceTable.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task which will download vocabulary update package from source host.
 * There are many URLs (in see the https://github.com/OHDSI/Vocabulary-v5.0/blob/master/LOINC/readme.md for details)
 */
task downloadUpdatePack(dependsOn: createSourceTable, description: project.properties['downloadUpdatePack.description']) << {
    println '\n\n*******************************************************'
    println '*                                                     *'
    println "*    '${description}' action started...     *"
    println '*                                                     *'
    println '*******************************************************'

    /* Downloading file */
    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    DownloadResourceHelper downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(tempDir);

    // Login LOINC service
    println "\n${new StringBuilderWrapper("Login LOINC service...")}"
    String loginUrl = project.properties['downloadUpdatePack.loinc.loginUrl']
    String userName = project.properties['downloadUpdatePack.loinc.username']
    String password = project.properties['downloadUpdatePack.loinc.password']
    downloadHelper.loginLoinc(loginUrl, userName, password)

    /*************************************************
     * Download 'Full Set' package (from LOINC portal)
     * **********************************************/
    String packageDescription = project.properties['downloadUpdatePack.fullSet.description']
    println new StringBuilderWrapper("\nDownloading ${packageDescription}...")
    String fileUrl = project.properties['downloadUpdatePack.fullSet.fileUrl']
    String defaultFileName = project.properties['downloadUpdatePack.fullSet.fileName']
    downloadHelper.downloadResourceLoinc(fileUrl, defaultFileName, packageDescription)

    /*************************************************************
     * Download 'Multiaxial Hierarchy' package (from LOINC portal)
     * ***********************************************************/
    packageDescription = project.properties['downloadUpdatePack.multiaxialHierarchy.description']
    println new StringBuilderWrapper("\nDownloading ${packageDescription}...")
    fileUrl = project.properties['downloadUpdatePack.multiaxialHierarchy.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.multiaxialHierarchy.fileName']
    downloadHelper.downloadResourceLoinc(fileUrl, defaultFileName, packageDescription)

    /*********************************************************
     * Download 'Panels and Forms' package (from LOINC portal)
     * *******************************************************/
    packageDescription = project.properties['downloadUpdatePack.panelsForms.description']
    println new StringBuilderWrapper("\nDownloading ${packageDescription}...")
    fileUrl = project.properties['downloadUpdatePack.panelsForms.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.panelsForms.fileName']
    downloadHelper.downloadResourceLoinc(fileUrl, defaultFileName, packageDescription)

    /******************************************************************
     * Download 'CT Expression Association' package (from LOINC portal)
     * ****************************************************************/
    packageDescription = project.properties['downloadUpdatePack.expressionAssociation.description']
    println new StringBuilderWrapper("\nDownloading ${packageDescription}...")
    fileUrl = project.properties['downloadUpdatePack.expressionAssociation.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.expressionAssociation.fileName']
    downloadHelper.downloadResourceLoinc(fileUrl, defaultFileName, packageDescription)

    /****************************************************
     * Download 'CPT Mappings' package (from UMLS portal)
     * **************************************************/
    packageDescription = project.properties['downloadUpdatePack.cptMappings.description']
    println new StringBuilderWrapper("Downloading ${packageDescription}...")
    loginUrl = project.properties['downloadUpdatePack.umls.loginUrl']
    userName = project.properties['downloadUpdatePack.umls.username']
    password = project.properties['downloadUpdatePack.umls.password']
    fileUrl = project.properties['downloadUpdatePack.cptMappings.fileUrl']
    defaultFileName = project.properties['downloadUpdatePack.cptMappings.fileName']
    downloadHelper.downloadResourceUmls(loginUrl, userName, password, fileUrl,defaultFileName)

    println new StringBuilderWrapper("Downloaded complete.\nUpdate packages are saved to the: ${tempDir.getPath()}")

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

task extractFiles(dependsOn: downloadUpdatePack, description: project.properties['extractFiles.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /* Extracting file */
    def fileList = []
    def dir = tempDir
    dir.eachFile(FileType.FILES) { file ->
        fileList << file
        println new StringBuilderWrapper("extracting: ${file}")

        if (file.getPath().endsWith('zip')) {
            ant.unzip(src: file.getPath(), dest: tempDir, overwrite: false)
        }
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will com.odysseusinc.convert a XLS data file to CSV format.
 */
task xls2Csv(dependsOn: extractFiles, description: project.properties['xls2Csv.description']) << {
    println '\n\n*************************************************'
    println '*                                               *'
    println "*  '${description}' action started...  *"
    println '*                                               *'
    println '*************************************************'

    def inputFile = "${tempDir.getPath()}/${project.properties['xls2Csv.srcFileName']}"
    def outputFile = "${tempDir.getPath()}/${project.properties['xls2Csv.destFileName']}"

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()
    def timeFinish = timeStart

    // For storing data into CSV files
    StringBuffer data = new StringBuffer()
    try {
        FileOutputStream fos = new FileOutputStream(outputFile)

        // Get the workbook object for XLS file
        Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFile))
        // Get first sheet from the workbook
        Sheet sheet = workbook.getSheetAt(0)
//        Cell cell
//        Row row

        for (int i = 0; i < sheet.getLastRowNum(); i++){
            Row row = sheet.getRow(i)

            if (row!= null){
                for (int j = 0; j < row.getLastCellNum(); j++){
                    Cell cell = row.getCell(j)
                    if (cell == null){
                        data.append(";")
                    } else {
                        cell.setCellType(Cell.CELL_TYPE_STRING)
                        data.append("\"" + cell. toString().trim().replaceAll("\"", "'") + "\"" + ";")
//                        switch (cell.getCellType()) {
//                            case Cell.CELL_TYPE_BOOLEAN:
//                                data.append("\"" + cell.getBooleanCellValue() + "\"" + ";")
//                                break
//
//                            case Cell.CELL_TYPE_NUMERIC:
//                                data.append("\"" + cell.getNumericCellValue() + "\"" + ";")
//                                break
//
//                            case Cell.CELL_TYPE_STRING:
////                                if (!cell.getStringCellValue().contains("\"")){
//                                println cell.toString()
//                                    data.append("\"" + cell.getStringCellValue().trim().replaceAll("\"", "'") + "\"" + ";")
////                                } else {
////                                    data.append(";")
////                                }
//                                break
//
//                            case Cell.CELL_TYPE_BLANK:
//                                data.append("" + ";")
//                                break
//
//                            default:
//                                data.append(cell + ";")
//                        }



                    }
                }
                data.append('\n')
            } else {

            }
        }

        // Iterate through each rows from first sheet
//        Iterator<Row> rowIterator = sheet.iterator()
//        while (rowIterator.hasNext()) {
//            row = rowIterator.next()
//            // For each row, iterate through each columns
//            Iterator<Cell> cellIterator = row.cellIterator()
//            while (cellIterator.hasNext()) {
//                cell = cellIterator.next()
//
//                switch (cell.getCellType()) {
//                    case Cell.CELL_TYPE_BOOLEAN:
//                        data.append("\"" + cell.getBooleanCellValue() + "\"" + ";")
//                        break
//
//                    case Cell.CELL_TYPE_NUMERIC:
//                        data.append("\"" + cell.getNumericCellValue() + "\"" + ";")
//                        break
//
//                    case Cell.CELL_TYPE_STRING:
//                        data.append("\"" + cell.getStringCellValue().trim() + "\"" + ";")
//                        break
//
//                    case Cell.CELL_TYPE_BLANK:
//                        data.append("" + ";")
//                        break
//
//                    default:
//                        data.append(cell + ";")
//                }
//
//            }
//
//        }
        println new StringBuilderWrapper('files converted...')
        fos.write(data.toString().getBytes())
        fos.close()

        // Finish action checkpoint
        timeFinish = System.currentTimeMillis()

    }
    catch (FileNotFoundException e) {
        e.printStackTrace()
    }
    catch (IOException e) {
        e.printStackTrace()
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task performed import CSV data to database
 */
task importData(dependsOn: xls2Csv, description: project.properties['import.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*         '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def dataFile = "${tempDir.getPath()}/${project.properties['importData.dataFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['importData.logFileName']}"
    def discardFile = "${project.properties['logPath']}/${project.properties['importData.discardFileName']}"
    def badFile = "${project.properties['logPath']}/${project.properties['importData.badFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['importData.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['importData.streamErrFileName']}"

    def bosOut = new ByteArrayOutputStream(), bosErr = new ByteArrayOutputStream()
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    exec {
        executable "sqlldr"
        args "USERID=${project.properties['db.userName']}/${project.properties['db.password']}@${project.properties['db.tnsName']} " +
                "CONTROL=${project.properties['basePath']}/${project.properties['import.controlFileName']} DATA=$dataFile LOG=$logFile DISCARD=$discardFile BAD=$badFile"
        standardOutput = bosOut
        errorOutput = bosErr
    }
    def bisOut = new ByteArrayInputStream(bosOut.toByteArray())
    bisOut.withReader { out->
        out.eachLine {
            sout.append(it).append('\n')
        }
    }
    def bisErr = new ByteArrayInputStream(bosErr.toByteArray())
    bisErr.withReader { out ->
        out.eachLine {
            serr.append(it).append('\n')
        }
    }

    // Write to console
    /*
     *  When import prefer to write stream log to console (it's shorter)
     * */
    System.out.println(sout.toString())

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Load stage' script.
 * Seems it's is specific for each vocabulary.
 */
task loadStage(dependsOn: importData, description: project.properties['loadStage.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['loadStage.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['loadStage.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['loadStage.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['loadStage.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Genetic update' script.
 * It's common for all updated vocabularies and located in '\Vocabulary-v5.0\working\generic_update.sql' file.
 */
task genericUpdate(dependsOn: loadStage, description: project.properties['genericUpdate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*     '${description}' action started...      *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['genericUpdate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['genericUpdate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['genericUpdate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run scripts which allows to see the vocabulary update results
 */
task checkUpdateResults(dependsOn: genericUpdate, description: project.properties['checkUpdateResults.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*  '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['checkUpdateResults.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['checkUpdateResults.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sout = new StringBuilderWrapper(), serr = new StringBuilderWrapper()
    def sqlplus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlplus.consumeProcessOutput(sout, serr)
    sqlplus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to console
    try {
        // Write compact SQLPlus's spool log
        System.out.println(StringBuilderWrapper.readFromFile(new File(logFile)))
    } catch (IOException ioe) {
        // Write whole SQLPlus's log
        System.out.println(sout.toString())
    }

    // Write to log file
    File f = new File(streamLogFile)
    f.write(sout.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(serr.toString())

    /* Check for errors */
    if (project.properties['stop.on.error'].toBoolean() && (sqlplus.exitValue() != 0 || (serr != null && serr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlplus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Bootstrap action
 *
 * TODO: Needs to find solution to measure whole task chain execution.
 * TODO: This one via doFirst/doLast actions isn't working.
 */
task startUpdate(dependsOn: checkUpdateResults, description: project.properties['startUpdate.description']) {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*      '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema...\n"

    project.ext['logPath'] = "${project.properties['basePath']}/${project.properties['baseLogPath']}"
    def folder = new File(project.properties['logPath'])
    if (!folder.exists()) {
        folder.mkdirs()
        println "Log directory is created: ${folder.getPath()}"
    } else {
        FileUtils.cleanDirectory(folder)
        println "Log directory is cleaned: ${folder.getPath()}"
    }

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    doLast {
        // Finish action checkpoint
        def timeFinish = System.currentTimeMillis()

        // Measure time execution
        def timeElapsed = (timeFinish - timeStart) / 1000
        println "\n\nTotal time elapsed: ${timeElapsed} seconds."
        println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema is completed successfully..."
        println '***********************************************'
        println '*                                             *'
        println "*      '${description}' action is done...       *"
        println '*                                             *'
        println '***********************************************\n'
    }
}