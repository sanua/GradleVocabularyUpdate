/*
****************************
* HCPCS Vocabulary update  *
* Version 0.0.6            *
****************************
*/

group 'com.sci.vocabulary'
version '1.0-SNAPSHOT'

apply plugin: 'java'

sourceCompatibility = 1.8

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath 'org.apache.poi:poi:3.9'
        classpath 'org.apache.poi:poi-ooxml:3.9'
        classpath 'javax.mail:javax.mail-api:1.5.5'
        classpath group: 'commons-io', name: 'commons-io', version: '2.5'
        classpath 'org.apache.commons:commons-lang3:3.5'

    }
}


repositories {
    mavenLocal()
    mavenCentral()
}

configurations {
    mail
}

dependencies {
    mail 'org.apache.ant:ant-javamail:1.8.1'
}

/**
 * JAVA-CODE SECTION.
 *
 * Temporary java code are located here. If future it's need to move it toi separate java-module.
 */

import groovy.io.FileType
import org.apache.poi.ss.usermodel.Cell
import org.apache.poi.ss.usermodel.Row
import org.apache.poi.ss.usermodel.Workbook
import org.apache.poi.ss.usermodel.WorkbookFactory
import org.apache.poi.ss.usermodel.Sheet
import org.apache.commons.io.FileUtils
import org.apache.commons.lang3.StringUtils
import java.nio.charset.StandardCharsets

/*
task compileOne(type: JavaCompile) {
    source = sourceSets.main.java.srcDir
    include 'inc.odysseus.utils/StringBuilderWrapper.java'
    classpath = sourceSets.main.output.classesDir
    destinationDir = sourceSets.main.output.classesDir
}
compileOne.options.compilerArgs = ["-sourcepath", "${projectDir}/src/main/java"]
*/
/**
 * Auxiliary classes. TODO: Further should be used java-defined and compiled only
 */
class StringBuilderWrapper implements java.lang.Appendable {
    private static final String IDENT_CHAR = " " *4
    private StringBuilder wrapped

    StringBuilderWrapper() {
        wrapped = new StringBuilder()
    }

    StringBuilderWrapper(String value) {
        this()
        wrapped.append(IDENT_CHAR).append(value)
    }

    static StringBuilderWrapper getBuilder() {
        return new StringBuilderWrapper()
    }

    static String readFromFile(File file) {
        if (file == null)
            return ''
        def builder = getBuilder()
        def br = new BufferedReader(new FileReader(file))
        def strLine
        while ((strLine = br.readLine()) != null) {
            builder.append('\n').append(strLine)
        }
        return builder.toString()
    }

    @Override
    Appendable append(CharSequence csq) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq)
        return this
    }
    @Override
    Appendable append(CharSequence csq, int start, int end) throws IOException {
        wrapped.append(IDENT_CHAR).append(csq, start, end)
        return this
    }
    @Override
    Appendable append(char c) throws IOException {
        wrapped.append(IDENT_CHAR).append(c)
        return this
    }
    @Override
    String toString() {
        return wrapped.toString()
    }
}

class StringHelper {
    public static final String CSV_FIELD_SEPARATOR = ";"

    static String normalizeString(String value) {
        String result = new String(value)
        // If empty - just return
        if (StringUtils.isBlank(value))
            return result
        boolean doubleQuiotesProcessed = false
        // Replace all number of double quotes by twice double quotes
        if (result.indexOf("\"") >= 0) {
            result = result.replaceAll("(\"+)", "\"\"")
            doubleQuiotesProcessed = true
        }
        // Replace all double quotes by
        if (result.indexOf(CSV_FIELD_SEPARATOR) >= 0 || doubleQuiotesProcessed) {
            result = String.format("\"%s\"", result)
        }
        // Replace all carriage return to space
        if (result.indexOf("\n") >= 0) {
            result = result.replaceAll("\n", " ")
        }
        // Replace all carriage return to space
        if (result.indexOf("\r") >= 0) {
            result = result.replaceAll("\r", " ")
        }
        // Replace x8093 hex chars after hyphens
        if (result.indexOf("\u2013") >= 0) {
            result = result.replaceAll("\u2013", "\u002D")
        }
        return result
    }
}

/**
 * JAVA-CODE SECTION
 */

// Load HCPCS properties
Properties props = new Properties()
props.load(new FileInputStream("${project.rootDir}/Update_HCPCS.properties"))
props.each {prop ->
    project.ext.set(prop.key, prop.value)
}
props.load(new FileInputStream("${project.getBuildFile().toString().replace('.gradle', '.properties')}"))
props.each {prop ->
    project.ext.set(prop.key, prop.value)
}

def tempDir = File.createTempDir()
tempDir.deleteOnExit()

/**
 * Just renew user schema and prepare it for further vocabulary update
 */
task fastRecreateSchema(description: project.properties['fastRecreate.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*       '${description}' action started...     *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['fastRecreate.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['fastRecreate.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['fastRecreate.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus -L ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will prepare user schema for vocabulary update routine.
 * It will create auxiliary table - the "ANWEB_V2" in our case, for example.
 */
task createSourceTable(dependsOn: fastRecreateSchema, description: project.properties['createSourceTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*   '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['createSourceTable.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['createSourceTable.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['createSourceTable.streamErrFileName']}"

    def db = [un     : project.properties['db.userName'],
              pw     : project.properties['db.password'],
              tns    : project.properties['db.tnsName'],
              sqlfile: sqlFile,
              logfile: logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task which will download vocabulary update package from source host.
 * This one - 'http://www.cms.gov/Medicare/Coding/HCPCSReleaseCodeSets/' is our case.
 */
task downloadUpdatePack(dependsOn: createSourceTable, description: project.properties['downloadUpdatePack.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...         *"
    println '*                                             *'
    println '***********************************************'

    /* Downloading file */
    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    println new StringBuilderWrapper('downloading file...')
    println new StringBuilderWrapper("stored to: ${tempDir.getPath()}")
    ant.get(src: project.properties['downloadUpdatePack.fileUrl'], dest: tempDir, verbose: true)
    println new StringBuilderWrapper('download completed')

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

task extractFiles(dependsOn: downloadUpdatePack, description: project.properties['extractFiles.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*        '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    /* Extracting file */
    def fileList = []
    def dir = tempDir
    dir.eachFile(FileType.FILES) { file ->
        fileList << file
        if (file.getPath().endsWith('zip')) {
            print new StringBuilderWrapper("Extracting ${file} ...")
            ant.unzip(src: file.getPath(), dest: tempDir, overwrite: false)
            println ' done'
        }
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will convert a XLS data file to CSV format.
 */
task xls2Csv(dependsOn: extractFiles, description: project.properties['xls2Csv.description']) << {
    println '\n\n*************************************************'
    println '*                                               *'
    println "*  '${description}' action started...  *"
    println '*                                               *'
    println '*************************************************'

    def inputFile = "${tempDir.getPath()}/${project.properties['xls2Csv.srcFileName']}"
    def outputFile = "${tempDir.getPath()}/${project.properties['xls2Csv.destFileName']}"

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    // For storing data into CSV files
    StringBuffer data = new StringBuffer()
    try {
        FileOutputStream fos = new FileOutputStream(outputFile)

        // Get the workbook object for XLS file
        Workbook workbook = WorkbookFactory.create(new FileInputStream(inputFile))
        // Get first sheet from the workbook
        Sheet sheet = workbook.getSheetAt(0)

        for (int i = 0; i <= sheet.getLastRowNum(); i++){
            Row row = sheet.getRow(i)

            if (row!= null){
                for (int j = 0; j < row.getLastCellNum(); j++){
                    Cell cell = row.getCell(j)
                    if (cell == null){
                        data.append(";")
                    } else {
                        cell.setCellType(Cell.CELL_TYPE_STRING)
                        String cellText = cell.toString().trim()

                        data.append(normalizeString(cellText))
                        if (j < row.getLastCellNum()) {
                            data.append(";")
                        }
                    }
                }
                data.append('\n')
            }
        }
        println new StringBuilderWrapper('file converted...')
        fos.write(data.toString().getBytes(StandardCharsets.UTF_8))
        fos.flush()

    } catch (Exception e) {
        throw new GradleException(String.format(project.properties['error.message'], e.getMessage(), name))
    } finally {
        if (fos != null)
            fos.close()
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Task performed import CSV data to database
 */
task importData(dependsOn: xls2Csv, description: project.properties['importData.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*         '${description}' action started...          *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def dataFile = "${tempDir.getPath()}/${project.properties['importData.dataFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['importData.logFileName']}"
    def discardFile = "${project.properties['logPath']}/${project.properties['importData.discardFileName']}"
    def badFile = "${project.properties['logPath']}/${project.properties['importData.badFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['importData.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['importData.streamErrFileName']}"

    def bosOut = new ByteArrayOutputStream(), bosErr = new ByteArrayOutputStream()
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    exec {
        executable "sqlldr"
        args "USERID=${project.properties['db.userName']}/${project.properties['db.password']}@${project.properties['db.tnsName']} " +
             "CONTROL=${project.properties['basePath']}/${project.properties['import.controlFileName']} " +
             "DATA=${dataFile} " +
             "LOG=${logFile} " +
             "DISCARD=${discardFile} " +
             "BAD=${badFile}"
        standardOutput = bosOut
        errorOutput = bosErr
    }
    def bisOut = new ByteArrayInputStream(bosOut.toByteArray())
    bisOut.withReader { out->
        out.eachLine {
            sOut.append(it).append('\n')
        }
    }
    def bisErr = new ByteArrayInputStream(bosErr.toByteArray())
    bisErr.withReader { out ->
        out.eachLine {
            sErr.append(it).append('\n')
        }
    }

    /**
     *  Write to console.
     *  When import prefer to write stream log to console (it's shorter).
     */
    System.out.println(sOut.toString())

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will run 'Load stage' script.
 * Seems it's is specific for each vocabulary.
 */
task loadStage(dependsOn: importData, description: project.properties['loadStage.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*     '${description}' action started...    *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['loadStage.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['loadStage.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['loadStage.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['loadStage.streamErrFileName']}"
    def logFileProcedureDrug = "${project.properties['logPath']}/${project.properties['loadStage.logProcedureDrugFileName']}"

    def db = [un                  : project.properties['db.userName'],
              pw                  : project.properties['db.password'],
              tns                 : project.properties['db.tnsName'],
              devSchema           : project.properties['vocabulary.dev.schema'],
              sqlfile             : sqlFile,
              logfile             : logFile,
              contextPath         : "${project.properties['basePath']}",
              logfileProcedureDrug: logFileProcedureDrug]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile} ${db.contextPath} ${db.logfileProcedureDrug} ${db.devSchema}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))
    lf = new File(logFileProcedureDrug)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    /* Check for errors */
    if (Boolean.valueOf(project.properties['stop.on.error'].toString()) && (sqlPlus.exitValue() != 0 || (sErr != null && sErr.toString().length() > 0))) {
        throw new GradleException(String.format(project.properties['error.message.with.code'], sqlPlus.exitValue(), name))
    }

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * This task will create 'Manual Table' to pass for manual mapping processing
 * */
task createManualTable(dependsOn: loadStage, description: project.properties['createManualTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*   '${description}' action started...   *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def sqlFile = "${project.properties['basePath']}/${project.properties['createManualTable.sqlFileName']}"
    def logFile = "${project.properties['logPath']}/${project.properties['createManualTable.logFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['createManualTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['createManualTable.streamErrFileName']}"

    def db = [un       : project.properties['db.userName'],
              pw       : project.properties['db.password'],
              tns      : project.properties['db.tnsName'],
              sqlfile  : sqlFile,
              tableName: "${project.properties['manualTableName']}",
              logfile  : logFile]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.logfile} ${db.tableName}""".execute()

    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    /**
     * Write to console.
     * Write compact SQLPlus's spool log
     */
    File lf = new File(logFile)
    if (lf.exists())
        System.out.println(StringBuilderWrapper.readFromFile(lf))

    // Write to logfile
    File f = new File(streamLogFile)
    f.write(sOut.toString())

    // Write to error file
    f = new File(streamErrorFile)
    f.write(sErr.toString())

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

task extractManualTable(/*dependsOn: [createManualTable, loadStage]*/dependsOn: createManualTable, description: project.properties['extractManualTable.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "* '${description}' action started... *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    // TODO: Need to deeply check why piped output does not works here (the > operator below)
    def sqlFile = "${project.properties['basePath']}/${project.properties['extractManualTable.sqlFileName']}"
    def streamLogFile = "${project.properties['logPath']}/${project.properties['extractManualTable.streamLogFileName']}"
    def streamErrorFile = "${project.properties['logPath']}/${project.properties['extractManualTable.streamErrFileName']}"

    def db = [un        : project.properties['db.userName'],
              pw        : project.properties['db.password'],
              tns       : project.properties['db.tnsName'],
              expPath   : "${project.properties['basePath']}",
              sqlfile   : sqlFile,
              expcsvfile: "${project.properties['manualTableFileName']}",
              tableName : "${project.properties['manualTableName']}"]
    def sOut = new StringBuilderWrapper(), sErr = new StringBuilderWrapper()
    print new StringBuilderWrapper('extracting table...')
    def sqlPlus = """sqlplus ${db.un}/${db.pw}@${db.tns} @${db.sqlfile} ${db.expPath} ${db.expcsvfile} ${db.tableName}""".execute()
    sqlPlus.consumeProcessOutput(sOut, sErr)
    sqlPlus.waitFor()
    println 'done'

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Write to logfile
    /**
     * Skip writing log file because it size could be so big.
     * Only error stream should be written.
     */
//    File f = new File(streamLogFile)
//    f.write(sout.toString())

    // Write to error file
    File f = new File(streamErrorFile)
    f.write(sErr.toString())

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000
    println "Time elapsed: ${timeElapsed} seconds."

    println "*** '${description}' action done ***"
}

/**
 * Send e-mail notification
 */
task sendMail(dependsOn: extractManualTable, description: project.properties['sendMail.description']) << {
    println '\n\n***********************************************'
    println '*                                             *'
    println "* '${description}' action started...  *"
    println '*                                             *'
    println '***********************************************'

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    def mailParams = [
            mailhost       : project.properties['sendMail.mailHost'],
            subject        : project.properties['sendMail.Subject'],
            messagemimetype: "text/plain",
            user           : project.properties['sendMail.user'],
            password       : project.properties['sendMail.password']
    ]

    println new StringBuilderWrapper('sending mail...')

    configurations.mail.each {
        org.apache.tools.ant.Project.class.classLoader.addURL(it.toURI().toURL())
    }

    ant.mail( mailParams ) {
        from(address: project.properties['sendMail.sentFrom'])
        to(address: project.properties['sendMail.sentTo'])
        message(String.format(project.properties['sendMail.Message'], "${project.properties['basePath']}/${project.properties['manualTableFileName']}"))
    }

    // Finish action checkpoint
    def timeFinish = System.currentTimeMillis()

    // Measure time execution
    def timeElapsed = (timeFinish - timeStart) / 1000

    println "Time elapsed: ${timeElapsed} seconds."
    println "*** '${description}' action done ***"
}

/**
 * Bootstrap action
 *
 * TODO: Needs to find solution to measure whole task chain execution.
 * TODO: This one via doFirst/doLast actions isn't working.
 */
task startUpdate(dependsOn: sendMail, description: project.properties['startUpdate.description']) {
    println '\n\n***********************************************'
    println '*                                             *'
    println "*      '${description}' action started...       *"
    println '*                                             *'
    println '***********************************************'

    println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema...\n"

    project.ext['logPath'] = "${project.properties['basePath']}/${project.properties['baseLogPath']}"
    def folder = new File(project.properties['logPath'])
    if (!folder.exists()) {
        folder.mkdirs()
        println "Log directory is created: ${folder.getPath()}"
    } else {
        FileUtils.cleanDirectory(folder)
        println "Log directory is cleaned: ${folder.getPath()}"
    }

    // Start action checkpoint
    def timeStart = System.currentTimeMillis()

    doLast {
        // Finish action checkpoint
        def timeFinish = System.currentTimeMillis()

        // Measure time execution
        def timeElapsed = (timeFinish - timeStart) / 1000
        println "\n\nTotal time elapsed: ${timeElapsed} seconds."
        println "Updating of '${project.properties['vocabulary.display.name']}' vocabulary on the '${project.properties['db.userName']}@${project.properties['db.tnsName']}' schema is completed successfully..."
        println '***********************************************'
        println '*                                             *'
        println "*      '${description}' action is done...       *"
        println '*                                             *'
        println '***********************************************\n'
    }
}