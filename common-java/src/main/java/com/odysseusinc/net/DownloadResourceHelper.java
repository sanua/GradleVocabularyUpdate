package com.odysseusinc.net;

import com.google.common.io.Files;
import com.odysseusinc.util.ExtractHelper;
import com.odysseusinc.util.IllegalUpdateStateException;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.*;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.cookie.Cookie;
import org.apache.http.entity.BufferedHttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.client.LaxRedirectStrategy;
import org.apache.http.impl.cookie.BasicClientCookie;
import org.apache.http.message.BasicNameValuePair;

import java.io.*;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Created by Sanders on 5/23/2017.
 */

public class DownloadResourceHelper {
    /**
     * Names of using cookies.
     *
     * COOKIE_JSESSIONID - session identifier on UMLS login service;
     * COOKIE_CASTGC - client authentication cookie for UMLS login service;
     * COOKIE_MOD_AUTH_CAS - client ticket-authentication cookie for UMLS download service.
     */
    public static final String COOKIE_JSESSIONID = "JSESSIONID";
    public static final String COOKIE_CASTGC = "CASTGC";
    public static final String COOKIE_CASPRIVACY = "CASPRIVACY";
    public static final String COOKIE_MOD_AUTH_CAS = "MOD_AUTH_CAS";
    public static final int NUMBER_OF_ATTEMPTS = 3;

    private CloseableHttpClient httpClient;
    private File downloadPath;
    private Properties resourceProperties;

    /**
     * Presumably "Login Ticket" parameter.
     * Used on user form during authentication, generated by UMLS login service when new session is created.
     */
    private String ltParam;

    /**
     * Class-level cookie store
     */
    private List<Cookie> localCookieStore;

    /**
     * Apache CookieStore for all cookies.
     * Isn't used because of using class-level cookie store.
     */
//    private CookieStore cookieStore;

    /**
     * Instance of Download Helper.
     */
    private static DownloadResourceHelper singleInstance;

    /**
     * Contructor
     */
    private DownloadResourceHelper(File downloadPath, boolean autoRedirects, String propertyFilePath) {
        if (downloadPath == null || !downloadPath.exists()) {
            // Prepare temporary storage for content
            this.downloadPath = Files.createTempDir();
            this.downloadPath.deleteOnExit();
        } else
            this.downloadPath = downloadPath;

        System.out.println(String.format("Used temporary folder: %s", this.downloadPath.getPath()));

        this.localCookieStore = new ArrayList<>();

        // Load resource properties
        this.resourceProperties = loadProps(propertyFilePath);

        // Create HttpClient
        HttpClientBuilder httpClientBuilder = HttpClients.custom()
                .setProxy(new HttpHost("127.0.0.1", 8888))
                .addInterceptorLast(
                        (HttpRequestInterceptor) (httpRequest, httpContext) -> {
                            debugRequestHeaders(httpRequest);
                        })
                .addInterceptorLast(
                        (HttpResponseInterceptor) (httpResponse, httpContext) -> {
                            debugResponseHeaders(httpResponse);
                        });

        // Configure HttpClient
        if (autoRedirects) {
            // With automatic redirect processing (further used for UMLS download)
            httpClientBuilder.setRedirectStrategy(new LaxRedirectStrategy()) // adds HTTP REDIRECT support to GET and POST methods
            ;
        } else {
            // With step-by-step redirect processing (firstly used for LOINC download)
            httpClientBuilder
                    .disableCookieManagement()
                    .disableRedirectHandling()
                    .addInterceptorLast(
                            (HttpRequestInterceptor) (httpRequest, httpContext) -> {
                                /**
                                 * Remove default headers
                                 */
                                httpRequest.removeHeaders("Accept");
                                httpRequest.removeHeaders("Accept-Encoding");
                                httpRequest.removeHeaders("Accept-Language");
                                httpRequest.removeHeaders("Connection");
                                httpRequest.removeHeaders("Cache-Control");
                                httpRequest.removeHeaders("Pragma");
                                httpRequest.removeHeaders("User-Agent");
                                httpRequest.removeHeaders("Referer");
                                /**
                                 * Add common request headers
                                 */
                                httpRequest.addHeader("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
                                httpRequest.addHeader("Accept-Encoding", "gzip, deflate, sdch, br");
                                httpRequest.addHeader("Accept-Language", "en-US,en;q=0.8,ru;q=0.6,uk;q=0.4");
                                httpRequest.addHeader("Cache-Control", "no-cache");
                                httpRequest.addHeader("Connection", "keep-alive");
                                httpRequest.addHeader("Pragma", "no-cache");
                                httpRequest.addHeader("Upgrade-Insecure-Requests", "1");
                                httpRequest.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36");

                            })
                    .addInterceptorLast(
                            (HttpResponseInterceptor) (httpResponse, httpContext) -> {
                                /**
                                 * Adding of cookie from response to class-level local storage.
                                 */
                                saveClientCookie(httpResponse);
                            });
        }
        this.httpClient = httpClientBuilder.build();
    }

    /**
     * Get Downloader instance
     *
     * @return
     */

    public static DownloadResourceHelper getDownloadResourceHelper(String propertyFileName) {
        return getDownloadResourceHelper(null, false, propertyFileName);
    }

    public static DownloadResourceHelper getDownloadResourceHelper(boolean autoRedirects, String propertyFileName) {
        return getDownloadResourceHelper(null, autoRedirects, propertyFileName);
    }

    public static DownloadResourceHelper getDownloadResourceHelper(File downloadPath, boolean autoRedirects, String propertyFileName) {
        if (singleInstance == null) {
            singleInstance = new DownloadResourceHelper(downloadPath, autoRedirects, propertyFileName);
        }
        return singleInstance;
    }

    /**
     * Extract header value from response
     *
     * @param response
     * @param name
     * @return
     */
    private String getResponseHeaderValue(HttpResponse response, String name) {
        Header header = response.getLastHeader(name);
        if (header == null) {
            return "";
        } else {
            return header.getValue();
        }
    }

    /**
     * Convert array to List
     *
     * @param objects
     * @return
     */
/*
    private <T> List<T> getListFromArray(T[] objects) {
        List<T> result = new ArrayList<T>();
        for (T c: objects) {
            if (c != null)
                result.add(c);
        }
        return result;
    }
*/

    /**
     * Return all saved client's cookies.
     *
     * @return
     */
    private List<Cookie> getAllStoredCookies() {
        List<Cookie> ckList = new ArrayList<>();
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            ckList.add(it.next());
        }
        return ckList;
    }

    /**
     * Get client cookie from local storage.
     *
     * @param name
     * @return
     */
    private Cookie getClientCookie(String name) {
        Cookie cookie = null;
        Iterator<Cookie> it = this.localCookieStore.iterator();
        while (it.hasNext()) {
            Cookie c = it.next();
            if (c.getName().equalsIgnoreCase(name)) {
                cookie = c;
                break;
            }
        }
        return cookie;
    }

    /**
     * Class-level Cookie Storage.
     *
     * @param response
     */
    private void saveClientCookie(HttpResponse response) {
        Header[] chArray = response.getHeaders("Set-Cookie");
        if (chArray == null)
            return;

        List<Header> chList = Arrays.asList(chArray);
        for (Header header: chList) {
            boolean skipCookie = false;
            String nameValue = header.getValue().substring(0, header.getValue().indexOf(";"));
            Cookie newCookie = new BasicClientCookie(nameValue.split("=")[0], nameValue.split("=")[1]);

            Iterator<Cookie> it = this.localCookieStore.iterator();
            while (it.hasNext()) {
                Cookie c = it.next();
                if (c.getName().equalsIgnoreCase(newCookie.getName())) {
                    skipCookie = true;
                    continue;
                }
            }
            if (!skipCookie)
                this.localCookieStore.add(newCookie);
        }
    }

    /**
     * Add multiple cookies to response.
     *
     * @param request
     * @param cookies
     * @return
     */
    private HttpRequest setRequestCookies(HttpRequest request, List<Cookie> cookies) {
        if (cookies == null || cookies.isEmpty())
            return request;

        StringBuilder sb = new StringBuilder();
        for (Cookie c: cookies) {
            if (c != null) {
                if (sb.toString().length() != 0)
                    sb.append(";");
                sb.append(String.format("%s=%s", c.getName(), c.getValue()));
            }
        }
        if (sb.length() > 0)
            request.addHeader("Cookie", sb.toString());
        return request;
    }

    /**
     * Convert parameter's map to name-value format, for convenient usage for Apache's classes.
     *
     * @param params
     * @return
     */
    private List<NameValuePair> toMapNameValuePairs(Map<String, String> params) {
        List<NameValuePair> nvpList = new ArrayList<>();
        Iterator<Map.Entry<String, String>> it = params.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, String> entry = it.next();
            String name = entry.getKey();
            String value = entry.getValue();
            if (StringUtils.isNotBlank(name) && StringUtils.isNoneBlank(value))
                nvpList.add(new BasicNameValuePair(name, value));
        }
        return nvpList;
    }

    /**
     * Prepare GET request.
     *
     * @param url
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url) throws IOException, URISyntaxException {
        return prepareGet(url, null, null);
    }

    /**
     * Prepare GET request with adding multiple cookies.
     *
     * @param url
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, List<Cookie> cookies) throws IOException, URISyntaxException {
        return prepareGet(url, null, cookies);
    }

    /**
     * Prepare parametrised GET request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpGet prepareGet(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        if (params != null && !params.isEmpty()) {
            URIBuilder uriBuilder = new URIBuilder(url);
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            uriBuilder.addParameters(pairList);
            url = uriBuilder.toString();
        }
        HttpGet request = new HttpGet(url);
        setRequestCookies(request, cookies);
        return request;
    }

    /**
     * Prepare parametrised POST request
     *
     * @param url
     * @param params
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params) throws IOException, URISyntaxException {
        return preparePost(url, params, null);
    }

    /**
     * Prepare parametrised POST request with adding multiple cookies.
     *
     * @param url
     * @param params
     * @param cookies
     * @return
     * @throws IOException
     * @throws URISyntaxException
     */
    private HttpPost preparePost(String url, Map<String, String> params, List<Cookie> cookies) throws IOException, URISyntaxException {
        HttpPost request = new HttpPost(url);
        if (params != null && !params.isEmpty()) {
            List<NameValuePair> pairList = toMapNameValuePairs(params);
            request.setEntity(new UrlEncodedFormEntity(pairList));
        }
        setRequestCookies(request, cookies);
        return request;
    }

    public String getDownloadPath() {
        return this.downloadPath.getPath();
    }

    /**
     * Return resource property value by it's name
     *
     * @param name
     * @return
     */
    public String getPropertyByName(String name) {
        return resourceProperties.getProperty(name);
    }

    /**
     * Load resource properties
     */
    public static Properties loadProps(String fileName) {
        Properties  resourceProperties = new Properties();
        if (StringUtils.isNotBlank(fileName)) {
            try {
                resourceProperties.load(new FileInputStream(fileName));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return resourceProperties;
    }

    /*
     * FOR TRACING PURPOSES ONLY
     */
    private void debugStepNumber(int stepNum, String fileUrl) {
        debugStepNumber(stepNum, fileUrl, "GET");
    }
    private void debugStepNumber(int stepNum, String fileUrl, String requestMethod) {
        System.out.println(String.format("\nStep %d. %s url: %s", stepNum, requestMethod, fileUrl));
    }

    private <T extends  HttpRequest> void debugRequestHeaders(T request) {
        System.out.println("!!!!! Request headers:");
        List<Header> lHeader = Arrays.asList(request.getAllHeaders());
        for (Header h: lHeader) {
            System.out.println(String.format("\t%s: %s", h.getName(), h.getValue()));
        }
    }

    private void debugResponseHeaders(HttpResponse response) {
        debugResponseHeaders(response, null);
    }

    private <T extends HttpResponse> void debugResponseHeaders(T response, String responseBody) {
        System.out.println("\n!!!!! Response:");
        System.out.println("\tresponse.getStatusLine():" + response.getStatusLine());
        System.out.println("\tcontent-type:" + getResponseHeaderValue(response, "Content-Type"));
        System.out.println("\tlocation:" + getResponseHeaderValue(response, "Location"));
        System.out.println("\tset-cookie:");
        List<Header> listHeaders = Arrays.asList(response.getHeaders("Set-Cookie"));
        for (Header h: listHeaders) {
            System.out.println("\t\t" + h.getValue());
        }
        System.out.println("\tcontent-disposition:" + getResponseHeaderValue(response, "Content-Disposition"));
        if (StringUtils.isNotBlank(responseBody))
            System.out.println("\tresponseBody:" + responseBody);

        List<Header> lHeader = Arrays.asList(response.getAllHeaders());
        for (Header h: lHeader) {
            System.out.println(String.format("\t%s: %s", h.getName(), h.getValue()));
        }
    }
    /*
     * FOR TRACING PURPOSES ONLY
     */

    public String repeatableDownloadUmlsResourceManualProcessing(String fileUrl, String userName, String password, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadUmlsResourceManualProcessing(fileUrl, userName, password, fileName, packageDescription,true, NUMBER_OF_ATTEMPTS);
    }

    public String repeatableDownloadUmlsResourceWithRedirects(String fileUrl, String userName, String password, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadUmlsResourceWithRedirects(fileUrl, userName, password, fileName, packageDescription,true, NUMBER_OF_ATTEMPTS);
    }

    public String repeatableDownloadLoincResource(String fileUrl, String fileName, String packageDescription) {
        /**
         * Try three times redownload if error occurs
         */
        return downloadLoincResource(fileUrl, fileName, packageDescription, true, NUMBER_OF_ATTEMPTS);
    }

    // Just login UMLS
    private boolean loginUmls(String loginUrl, String userName, String password) {
        CloseableHttpResponse response = null;
        try {
            HttpGet request = prepareGet(loginUrl);
            response = httpClient.execute(request);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                throw new HttpException(String.format("Unable to login UMLS service\n%s", response.getStatusLine()));
            } else
                return true;

        } catch (Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    // Just download UMLS routine
    public String downloadUmlsResource(String fileUrl, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        debugStepNumber(5, fileUrl);

        CloseableHttpResponse response = null;
        OutputStream outputStream = null;
        HttpGet request = null;
        try  {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_MOD_AUTH_CAS));
            request = prepareGet(fileUrl, cookies);

            debugRequestHeaders(request);

            response = httpClient.execute(request);

            debugResponseHeaders(response);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries >= 0) {
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    return downloadUmlsResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();
            return fileName;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
            try {
                if (outputStream != null)
                    outputStream.close();
            } catch (IOException ioe) {}
        }
    }

    // Login and download resource
    public String downloadUmlsResourceManualProcessing(String fileUrl, String userName, String password, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        this.localCookieStore.clear();

        /*
         * REQUEST 1
         * Just get JSESSION cookie
         */
        debugStepNumber(1, fileUrl);
        this.ltParam = requestUmlsLoginTicket(fileUrl);

        /*
         * REQUEST 2
         * Login to UMLS
         */
        CloseableHttpResponse response = null;
        HttpPost postRequest = null;
        System.out.println("Login UMLS service...");
        debugStepNumber(2, fileUrl);
        try {
            Map<String, String> params = new HashMap<>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            postRequest = preparePost(fileUrl, params, cookies);
            postRequest.addHeader("Content-Type", "application/x-www-form-urlencoded");

            debugRequestHeaders(postRequest);

            response = httpClient.execute(postRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        /*
         * REQUEST 3
         * Authorize on download service with ticket
         */
        debugStepNumber(3, fileUrl);
        HttpGet getRequest= null;
        try {
            List<Cookie> cookies = new ArrayList<>();
            cookies.add(getClientCookie(COOKIE_JSESSIONID));
            cookies.add(getClientCookie(COOKIE_CASTGC));
            getRequest = prepareGet(fileUrl, cookies);

            debugRequestHeaders(getRequest);

            response = httpClient.execute(getRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            getRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        /*
         * REQUEST 4
         * Authorize on download service
         * Seems that this piece of code is redundant.
         */
/*
        debugStepNumber(4, fileUrl);
        if (getRequest != null)
            getRequest.reset();
        try {
            getRequest = prepareGet(fileUrl);

            debugRequestHeaders(getRequest);

            response = httpClient.execute(getRequest);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Get URL for further processing
            String locationHeaderValue = getResponseHeaderValue(response, "Location");
            if (StringUtils.isNotBlank(locationHeaderValue))
                fileUrl = locationHeaderValue;

        } catch (Exception e) {
            getRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
*/

        /*
         * REQUEST final
         * Download resource
         */
        return downloadUmlsResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
    }

    private String requestUmlsLoginTicket(String url) {
        CloseableHttpResponse response = null;
        HttpGet request = null;
        try {
            request = prepareGet(url);

            debugRequestHeaders(request);

            response = httpClient.execute(request);

            // Buffer response content
            BufferedHttpEntity bufEntity = new BufferedHttpEntity(response.getEntity());
            StringWriter writer = new StringWriter();
            IOUtils.copy(bufEntity.getContent(), writer, StandardCharsets.UTF_8);
            writer.flush();
            String responseBody = writer.toString().trim();

            debugResponseHeaders(response, responseBody);

            // Remember dynamically generated presumably "Login Ticket" form parameter
            Pattern ltPattern = Pattern.compile("name=\"lt\" value=\"(\\w+)\"");
            Matcher m = ltPattern.matcher(responseBody);
            String ltParam = StringUtils.EMPTY;
            while (m.find()) {
                ltParam = m.group(1);
            }
            return ltParam;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    public String downloadUmlsResourceWithRedirects(String fileUrl, String userName, String password, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        /*
         * REQUEST 1
         * Just get JSESSION cookie
         */
        debugStepNumber(1, fileUrl);
        this.ltParam = requestUmlsLoginTicket(fileUrl);

        /*
         * REQUEST 2
         * Login to UMLS and download package
         */
        CloseableHttpResponse response = null;
        OutputStream outputStream;
        HttpPost postRequest = null;
        System.out.println("Login UMLS service...");
        debugStepNumber(2, fileUrl, "POST");
        try {
            Map<String, String> params = new HashMap<>();
            params.put("username", userName);
            params.put("password", password);
            params.put("lt", this.ltParam);
            params.put("_eventId", "submit");
            params.put("submit", "Sign In");
            postRequest = preparePost(fileUrl, params);
            postRequest.addHeader("Content-Type", "application/x-www-form-urlencoded");

            debugRequestHeaders(postRequest);

            response = httpClient.execute(postRequest);

            debugResponseHeaders(response);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries >= 0) {
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....",
                            response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadUmlsResourceWithRedirects(fileUrl, userName, password, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0)
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();

        } catch (Exception e) {
            postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }

        return fileName;
    }

    public boolean loginLoinc(String loginUrl, String userName, String password) {
        CloseableHttpResponse response = null;
        HttpPost request = null;
        // Login LOINC services
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("log", userName);
            params.put("pwd", password);
            params.put("wp-submit", "Log In");
            request = preparePost(loginUrl, params);
            response = httpClient.execute(request);
            return true;

        } catch (Exception e) {
            if (request != null)
                request.abort();
            e.printStackTrace();
            return false;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
        }
    }

    public String downloadLoincResource(String fileUrl, String fileName, String packageDescription, boolean isTryRedownload, int numberOfTries) {
        OutputStream outputStream = null;
        CloseableHttpResponse response = null;
        HttpPost postRequest = null;
        try {
            Map<String, String> params = new HashMap<String, String>();
            params.put("tc_accepted", "1");
            params.put("tc_submit", "Download");
            List<Cookie> cookies = getAllStoredCookies();
            postRequest = preparePost(fileUrl, params, cookies);
            response = httpClient.execute(postRequest);

            int responseCode = response.getStatusLine().getStatusCode();
            if (responseCode != HttpStatus.SC_OK) {
                numberOfTries--;
                if (isTryRedownload && numberOfTries > 0) {
                    if (response != null)
                        try {
                            response.close();
                        } catch (IOException ioe) {}
                    System.out.println(String.format("Attention!\nThere is some problem of content downloading: %s.\nTry again, attempt %d of %d....", response.getStatusLine(), NUMBER_OF_ATTEMPTS - numberOfTries, NUMBER_OF_ATTEMPTS));
                    return downloadLoincResource(fileUrl, fileName, packageDescription, isTryRedownload, numberOfTries);
                } else {
                    throw new HttpException(String.format("Unable to download %s\n%s", packageDescription, response.getStatusLine()));
                }
            } else if (getResponseHeaderValue(response, "Content-Type").indexOf("zip") < 0) {
                throw new HttpException(String.format("%s is not a ZIP archive", packageDescription));
            }

            debugResponseHeaders(response);

            // Eval downloaded file name
            String contentDisposition = getResponseHeaderValue(response, "Content-Disposition");
            if (contentDisposition.length() > 0) {
                fileName = contentDisposition.substring(contentDisposition.lastIndexOf("filename") + 9).replace("\"", "").replace(";", "");
            }
            String filePath = String.format("%s%s%s", this.downloadPath.getPath(), File.separator, fileName);

            String contentLength = getResponseHeaderValue(response,"Content-Length");
            System.out.println(String.format("Downloaded '%s' file with %s bytes", fileName, contentLength));

            // Save file to stream
            outputStream = new FileOutputStream(new File(filePath));
            IOUtils.copyLarge(response.getEntity().getContent(), outputStream);
            outputStream.flush();
            return fileName;

        } catch (Exception e) {
            if (postRequest != null)
                postRequest.abort();
            e.printStackTrace();
            return StringUtils.EMPTY;
        } finally {
            try {
                if (response != null)
                    response.close();
            } catch (IOException ioe) {}
            try {
                if (outputStream != null)
                    outputStream.close();
            } catch (IOException ioe) {}
        }
    }

    /**
     * Test usages
     */
    public static void testDownloadLoinc(DownloadResourceHelper downloadHelper, boolean downloadUmlsWithRedirects) {
        // Login LOINC service
        System.out.println("\nLogin LOINC service...");
        String url = downloadHelper.getPropertyByName("downloadUpdatePack.loinc.loginUrl");
        String userName = downloadHelper.getPropertyByName("downloadUpdatePack.loinc.username");
        String password = downloadHelper.getPropertyByName("downloadUpdatePack.loinc.password");
        downloadHelper.loginLoinc(url, userName, password);

        // Download 'Full Set' package
        String packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.fullSet.description");
        System.out.println(String.format("\nDownload %s...", packageDescription));
        String fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.fullSet.fileUrl");
        String defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.fullSet.fileName");
        downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription);

        // Download 'Multiaxial Hierarchy' package
        packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.multiaxialHierarchy.description");
        System.out.println(String.format("\nDownload %s...", packageDescription));
        fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.multiaxialHierarchy.fileUrl");
        defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.multiaxialHierarchy.fileName");
        downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription);

        // Download 'Panels and Forms' package
        packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.panelsForms.description");
        System.out.println(String.format("\nDownload %s...", packageDescription));
        fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.panelsForms.fileUrl");
        defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.panelsForms.fileName");
        downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription);

        // Download 'CT Expression Association' package
        packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.expressionAssociation.description");
        System.out.println(String.format("\nDownload %s...", packageDescription));
        fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.expressionAssociation.fileUrl");
        defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.expressionAssociation.fileName");
        downloadHelper.repeatableDownloadLoincResource(fileUrl, defaultFileName, packageDescription);

        // Login and download from UMLS service
        System.out.println("\nLogin and download from UMLS service...");
        packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.cptMappings.description");
//        url = getPropertyByName("downloadUpdatePack.umls.loginUrl");
        userName = downloadHelper.getPropertyByName("downloadUpdatePack.umls.username");
        password = downloadHelper.getPropertyByName("downloadUpdatePack.umls.password");
        fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.cptMappings.fileUrl");
        defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.cptMappings.fileName");
        if (downloadUmlsWithRedirects) {
            System.out.println(String.format("!!! Download UMLS with redirects..."));
            downloadHelper.repeatableDownloadUmlsResourceWithRedirects(fileUrl, userName, password, defaultFileName, packageDescription);
        } else {
            System.out.println(String.format("!!! Download UMLS with manual processing..."));
            downloadHelper.repeatableDownloadUmlsResourceManualProcessing(fileUrl, userName, password, defaultFileName, packageDescription);
        }
    }

    public static void testDownloadUmlsManually(DownloadResourceHelper downloadHelper) {
        /*
         * Downloading file
         * Start action checkpoint
         */
        long timeStart = System.currentTimeMillis();

        /*
         * Login 'UMLS' service and Download 'UMLS' package
         */
//        String loginUrl = getPropertyByName("downloadUpdatePack.umls.loginUrl");
        String userName = downloadHelper.getPropertyByName("downloadUpdatePack.umls.username");
        String password = downloadHelper.getPropertyByName("downloadUpdatePack.umls.password");
        String packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.description");
        System.out.println("Downloading " + packageDescription);
        String fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.fileUrl");
        String defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.fileName");
        String downloadedFileName = downloadHelper.repeatableDownloadUmlsResourceManualProcessing(fileUrl, userName, password, defaultFileName, packageDescription);
        System.out.println("Downloaded file: " + downloadedFileName);
        System.out.println("Downloaded complete.\nUpdate packages are saved to the: " + downloadHelper.getDownloadPath());

        // Finish action checkpoint
        long timeFinish = System.currentTimeMillis();
        long timeElapsed = (timeFinish - timeStart) / 1000;
        System.out.println("Time elapsed: " + timeElapsed + " seconds.");

        System.out.println("*** " + packageDescription + " action done ***");
    }

    public static void testDownloadUmlsWithRedirects(DownloadResourceHelper downloadHelper) {
        /* Downloading file */
        // Start action checkpoint
        long timeStart = System.currentTimeMillis();

        /*
         * Login  and download 'Full UMLS' package
         */
        String fileUrl = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.fileUrl");
        String userName = downloadHelper.getPropertyByName("downloadUpdatePack.umls.username");
        String password = downloadHelper.getPropertyByName("downloadUpdatePack.umls.password");
        String packageDescription = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.description");
        System.out.println("Downloading " + packageDescription);
        String defaultFileName = downloadHelper.getPropertyByName("downloadUpdatePack.umlsFull.fileName");
        String downloadedFileName = downloadHelper.repeatableDownloadUmlsResourceWithRedirects(fileUrl, userName, password, defaultFileName, packageDescription);
        System.out.println("Downloaded file: " + downloadedFileName);

        System.out.println("Downloaded complete.\nUpdate packages are saved to the: " + downloadHelper.getDownloadPath());

        // Finish action checkpoint
        long timeFinish = System.currentTimeMillis();
        long timeElapsed = (timeFinish - timeStart) / 1000;
        System.out.println("Time elapsed: " + timeElapsed + " seconds.");

        System.out.println("*** " + packageDescription + " action done ***");
    }

    public static String testExtract() {
        File temp = Files.createTempDir();
        temp.deleteOnExit();

        ExtractHelper extractHelper = ExtractHelper.getInstance(temp);

        List<String> checkedFileNameList = new ArrayList<>();
        Properties props = loadProps("./Update_UMLS.properties");
        String checkedFilesString = props.getProperty("prepareFiles.files");
        if (StringUtils.isNotBlank(checkedFilesString))
            checkedFileNameList = Arrays.asList(checkedFilesString.split(","));

        File src = new File("E:\\temp\\data");

        FileFilter fileFilter = pathname -> pathname.getName().toLowerCase().endsWith("zip")
                || pathname.getName().toLowerCase().endsWith("gz");
        for (File f : src.listFiles(fileFilter)) {
            if (!extractHelper.extractArchive(f, temp, checkedFileNameList)) {
                System.out.println(String.format("!!! Cannot extract file: %s", f.getPath()));
            }
        }
        return temp.getPath();
    }

    public static String testExtractUMLS() throws IOException {
        // Start action checkpoint
        long timeStart = System.currentTimeMillis();

        List<String> checkedFileNameList = new ArrayList<>();
        Properties props = loadProps("./Update_UMLS.properties");
        String checkedFilesString = props.getProperty("prepareFiles.files");
        if (StringUtils.isNotBlank(checkedFilesString))
            checkedFileNameList = Arrays.asList(checkedFilesString.split(","));

        File workDir = new File("E:\\temp\\groovy-generated-5406289380510812740-tmpdir");
        ExtractHelper extractHelper = ExtractHelper.getInstance(workDir);
        extractHelper.extract(workDir, checkedFileNameList);

        // Finish action checkpoint
        long timeFinish = System.currentTimeMillis();

        // Measure time execution
        long timeElapsed = (timeFinish - timeStart) / 1000;
        System.out.println(String.format("Time elapsed: %,d seconds.", timeElapsed));
        return workDir.getPath();
    }

    public static void testConcatenate(String filesPath) throws IOException {
        File fPath = new File(filesPath);

        List<String> fileMaskList = Arrays.asList("MRCONSO", "MRHIER", "MRSAT");
        LinkedHashMap<String, TreeSet<File>> orderedFilesParts = new LinkedHashMap<>();
        for (String fileMask: fileMaskList) {
            TreeSet<File> orderedFiles = new TreeSet<>();

            FileFilter fileFilter = pathname -> pathname.getName().toLowerCase().indexOf(fileMask.toLowerCase()) >= 0;
            for (File f : fPath.listFiles(fileFilter)) {
                orderedFiles.add(f);
            }
            String fileName = orderedFiles.first().getName();
            fileName = fileName.substring(0, fileName.lastIndexOf("."));
            orderedFilesParts.put(fileName, orderedFiles);
        }

        Iterator<Map.Entry<String, TreeSet<File>>> it = orderedFilesParts.entrySet().iterator();
        while(it.hasNext()) {
            Map.Entry<String, TreeSet<File>> e = it.next();
            String targetFile = new File(fPath, e.getKey()).getPath();
            System.out.print(String.format("Concatenating all parts of the %s file ... ", targetFile));
            FileOutputStream fos = new FileOutputStream(targetFile);
            try {
                Iterator<File> fit = e.getValue().iterator();
                while (fit.hasNext()) {
                    File partFile = fit.next();
                    FileInputStream fis = new FileInputStream(partFile);
                    try {
                        byte[] buff = new byte[8192];
                        int bytesRead;
                        while((bytesRead = fis.read(buff, 0, buff.length)) != -1) {
                            fos.write(buff, 0, bytesRead);
                        }
                    } finally {
                        if (fis != null)
                            fis.close();
                    }
                    fos.flush();
                }
            } finally {
                if (fos != null)
                    fos.close();
            }
            System.out.println(" done");
        }
    }
    /*
     * Test usages
     */

    public static void main(String[] args) throws IllegalUpdateStateException, IOException {
        DownloadResourceHelper downloadHelper = null;

//        downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(false, "./Update_LOINC.properties");
//        testDownloadLoinc(downloadHelper, false);

//        downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(true, "./Update_LOINC.properties");
//        testDownloadLoinc(downloadHelper, true);

//        downloadHelper = DownloadResourceHelper.getDownloadResourceHelper("./Update_UMLS.properties");
//        testDownloadUmlsManually(downloadHelper);

//        downloadHelper = DownloadResourceHelper.getDownloadResourceHelper(true, "./Update_UMLS.properties");
//        testDownloadUmlsWithRedirects(downloadHelper);

//        String targetPath = testExtract();

//        String targetPath = testExtractUMLS();

        String workPath = "E:\\temp\\groovy-generated-5406289380510812740-tmpdir";
        testConcatenate(workPath);
    }
}